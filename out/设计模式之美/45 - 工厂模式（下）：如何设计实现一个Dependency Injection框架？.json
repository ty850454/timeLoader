{"error":[],"extra":[],"data":{"video_id":"","sku":"100039001","video_cover":"","author_name":"王争","text_read_version":0,"audio_size":9381868,"article_cover":"https:\/\/static001.geekbang.org\/resource\/image\/40\/b2\/4005422bef734b1ba5148bf0e6ad05b2.jpg","product_type":"c1","audio_url":"https:\/\/res001.geekbang.org\/\/media\/audio\/96\/ff\/9656485234582086d0fdd37ed1bc4fff\/ld\/ld.m3u8","chapter_id":"1246","column_had_sub":true,"audio_dubber":"冯永吉","is_finished":false,"like":{"had_done":false,"count":14},"neighbors":{"left":{"article_title":"44 | 工厂模式（上）：我为什么说没事不要随便用工厂模式创建对象？","id":197254},"right":{"article_title":"46 | 建造者模式：详解构造函数、set方法、建造者模式三种对象创建方式","id":199674}},"audio_time":"00:11:09","video_height":0,"rate_percent":0,"article_content":"<p>在上一节课我们讲到，当创建对象是一个“大工程”的时候，我们一般会选择使用工厂模式，来封装对象复杂的创建过程，将对象的创建和使用分离，让代码更加清晰。那何为“大工程”呢？上一节课中我们讲了两种情况，一种是创建过程涉及复杂的if-else分支判断，另一种是对象创建需要组装多个其他类对象或者需要复杂的初始化过程。<\/p><p>今天，我们再来讲一个创建对象的“大工程”，依赖注入框架，或者叫依赖注入容器（Dependency Injection Container），简称DI容器。在今天的讲解中，我会带你一块搞清楚这样几个问题：DI容器跟我们讲的工厂模式又有何区别和联系？DI容器的核心功能有哪些，以及如何实现一个简单的DI容器？<\/p><p>话不多说，让我们正式开始今天的学习吧！<\/p><h2>工厂模式和DI容器有何区别？<\/h2><p>实际上，DI容器底层最基本的设计思路就是基于工厂模式的。DI容器相当于一个大的工厂类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获取即可。正是因为它持有一堆对象，所以这个框架才被称为“容器”。<\/p><p>DI容器相对于我们上节课讲的工厂模式的例子来说，它处理的是更大的对象创建工程。上节课讲的工厂模式中，一个工厂类只负责某个类对象或者某一组相关类对象（继承自同一抽象类或者接口的子类）的创建，而DI容器负责的是整个应用中所有类对象的创建。<\/p><!-- [[[read_end]]] --><p>除此之外，DI容器负责的事情要比单纯的工厂模式要多。比如，它还包括配置的解析、对象生命周期的管理。接下来，我们就详细讲讲，一个简单的DI容器应该包含哪些核心功能。<\/p><h2>DI容器的核心功能有哪些？<\/h2><p>总结一下，一个简单的DI容器的核心功能一般有三个：配置解析、对象创建和对象生命周期管理。<\/p><p><strong>首先，我们来看配置解析。<\/strong><\/p><p>在上节课讲的工厂模式中，工厂类要创建哪个类对象是事先确定好的，并且是写死在工厂类代码中的。作为一个通用的框架来说，框架代码跟应用代码应该是高度解耦的，DI容器事先并不知道应用会创建哪些对象，不可能把某个应用要创建的对象写死在框架代码中。所以，我们需要通过一种形式，让应用告知DI容器要创建哪些对象。这种形式就是我们要讲的配置。<\/p><p>我们将需要由DI容器来创建的类对象和创建类对象的必要信息（使用哪个构造函数以及对应的构造函数参数都是什么等等），放到配置文件中。容器读取配置文件，根据配置文件提供的信息来创建对象。<\/p><p>下面是一个典型的Spring容器的配置文件。Spring容器读取这个配置文件，解析出要创建的两个对象：rateLimiter和redisCounter，并且得到两者的依赖关系：rateLimiter依赖redisCounter。<\/p><pre><code>public class RateLimiter {\n  private RedisCounter redisCounter;\n  public RateLimiter(RedisCounter redisCounter) {\n    this.redisCounter = redisCounter;\n  }\n  public void test() {\n    System.out.println(&quot;Hello World!&quot;);\n  }\n  \/\/...\n}\n\npublic class RedisCounter {\n  private String ipAddress;\n  private int port;\n  public RedisCounter(String ipAddress, int port) {\n    this.ipAddress = ipAddress;\n    this.port = port;\n  }\n  \/\/...\n}\n\n配置文件beans.xml：\n&lt;beans&gt;\n   &lt;bean id=&quot;rateLimiter&quot; class=&quot;com.xzg.RateLimiter&quot;&gt;\n      &lt;constructor-arg ref=&quot;redisCounter&quot;\/&gt;\n   &lt;\/bean&gt;\n \n   &lt;bean id=&quot;redisCounter&quot; class=&quot;com.xzg.redisCounter&quot;&gt;\n     &lt;constructor-arg type=&quot;String&quot; value=&quot;127.0.0.1&quot;&gt;\n     &lt;constructor-arg type=&quot;int&quot; value=1234&gt;\n   &lt;\/bean&gt;\n&lt;\/beans&gt;\n<\/code><\/pre><p><strong>其次，我们再来看对象创建。<\/strong><\/p><p>在DI容器中，如果我们给每个类都对应创建一个工厂类，那项目中类的个数会成倍增加，这会增加代码的维护成本。要解决这个问题并不难。我们只需要将所有类对象的创建都放到一个工厂类中完成就可以了，比如BeansFactory。<\/p><p>你可能会说，如果要创建的类对象非常多，BeansFactory中的代码会不会线性膨胀（代码量跟创建对象的个数成正比）呢？实际上并不会。待会讲到DI容器的具体实现的时候，我们会讲“反射”这种机制，它能在程序运行的过程中，动态地加载类、创建对象，不需要事先在代码中写死要创建哪些对象。所以，不管是创建一个对象还是十个对象，BeansFactory工厂类代码都是一样的。<\/p><p><strong>最后，我们来看对象的生命周期管理。<\/strong><\/p><p>上一节课我们讲到，简单工厂模式有两种实现方式，一种是每次都返回新创建的对象，另一种是每次都返回同一个事先创建好的对象，也就是所谓的单例对象。在Spring框架中，我们可以通过配置scope属性，来区分这两种不同类型的对象。scope=prototype表示返回新创建的对象，scope=singleton表示返回单例对象。<\/p><p>除此之外，我们还可以配置对象是否支持懒加载。如果lazy-init=true，对象在真正被使用到的时候（比如：BeansFactory.getBean(“userService”)）才被被创建；如果lazy-init=false，对象在应用启动的时候就事先创建好。<\/p><p>不仅如此，我们还可以配置对象的init-method和destroy-method方法，比如init-method=loadProperties()，destroy-method=updateConfigFile()。DI容器在创建好对象之后，会主动调用init-method属性指定的方法来初始化对象。在对象被最终销毁之前，DI容器会主动调用destroy-method属性指定的方法来做一些清理工作，比如释放数据库连接池、关闭文件。<\/p><h2>如何实现一个简单的DI容器？<\/h2><p>实际上，用Java语言来实现一个简单的DI容器，核心逻辑只需要包括这样两个部分：配置文件解析、根据配置文件通过“反射”语法来创建对象。<\/p><h3>1.最小原型设计<\/h3><p>因为我们主要是讲解设计模式，所以，在今天的讲解中，我们只实现一个DI容器的最小原型。像Spring框架这样的DI容器，它支持的配置格式非常灵活和复杂。为了简化代码实现，重点讲解原理，在最小原型中，我们只支持下面配置文件中涉及的配置语法。<\/p><pre><code>配置文件beans.xml\n&lt;beans&gt;\n   &lt;bean id=&quot;rateLimiter&quot; class=&quot;com.xzg.RateLimiter&quot;&gt;\n      &lt;constructor-arg ref=&quot;redisCounter&quot;\/&gt;\n   &lt;\/bean&gt;\n \n   &lt;bean id=&quot;redisCounter&quot; class=&quot;com.xzg.redisCounter&quot; scope=&quot;singleton&quot; lazy-init=&quot;true&quot;&gt;\n     &lt;constructor-arg type=&quot;String&quot; value=&quot;127.0.0.1&quot;&gt;\n     &lt;constructor-arg type=&quot;int&quot; value=1234&gt;\n   &lt;\/bean&gt;\n&lt;\/bean\n<\/code><\/pre><p>最小原型的使用方式跟Spring框架非常类似，示例代码如下所示：<\/p><pre><code>public class Demo {\n  public static void main(String[] args) {\n    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\n            &quot;beans.xml&quot;);\n    RateLimiter rateLimiter = (RateLimiter) applicationContext.getBean(&quot;rateLimiter&quot;);\n    rateLimiter.test();\n    \/\/...\n  }\n}\n<\/code><\/pre><h3>2.提供执行入口<\/h3><p>前面我们讲到，面向对象设计的最后一步是：组装类并提供执行入口。在这里，执行入口就是一组暴露给外部使用的接口和类。<\/p><p>通过刚刚的最小原型使用示例代码，我们可以看出，执行入口主要包含两部分：ApplicationContext和ClassPathXmlApplicationContext。其中，ApplicationContext是接口，ClassPathXmlApplicationContext是接口的实现类。两个类具体实现如下所示：<\/p><pre><code>public interface ApplicationContext {\n  Object getBean(String beanId);\n}\n\npublic class ClassPathXmlApplicationContext implements ApplicationContext {\n  private BeansFactory beansFactory;\n  private BeanConfigParser beanConfigParser;\n\n  public ClassPathXmlApplicationContext(String configLocation) {\n    this.beansFactory = new BeansFactory();\n    this.beanConfigParser = new XmlBeanConfigParser();\n    loadBeanDefinitions(configLocation);\n  }\n\n  private void loadBeanDefinitions(String configLocation) {\n    InputStream in = null;\n    try {\n      in = this.getClass().getResourceAsStream(&quot;\/&quot; + configLocation);\n      if (in == null) {\n        throw new RuntimeException(&quot;Can not find config file: &quot; + configLocation);\n      }\n      List&lt;BeanDefinition&gt; beanDefinitions = beanConfigParser.parse(in);\n      beansFactory.addBeanDefinitions(beanDefinitions);\n    } finally {\n      if (in != null) {\n        try {\n          in.close();\n        } catch (IOException e) {\n          \/\/ TODO: log error\n        }\n      }\n    }\n  }\n\n  @Override\n  public Object getBean(String beanId) {\n    return beansFactory.getBean(beanId);\n  }\n}\n<\/code><\/pre><p>从上面的代码中，我们可以看出，ClassPathXmlApplicationContext负责组装BeansFactory和BeanConfigParser两个类，串联执行流程：从classpath中加载XML格式的配置文件，通过BeanConfigParser解析为统一的BeanDefinition格式，然后，BeansFactory根据BeanDefinition来创建对象。<\/p><h3>3.配置文件解析<\/h3><p>配置文件解析主要包含BeanConfigParser接口和XmlBeanConfigParser实现类，负责将配置文件解析为BeanDefinition结构，以便BeansFactory根据这个结构来创建对象。<\/p><p>配置文件的解析比较繁琐，不涉及我们专栏要讲的理论知识，不是我们讲解的重点，所以这里我只给出两个类的大致设计思路，并未给出具体的实现代码。如果感兴趣的话，你可以自行补充完整。具体的代码框架如下所示：<\/p><pre><code>public interface BeanConfigParser {\n  List&lt;BeanDefinition&gt; parse(InputStream inputStream);\n  List&lt;BeanDefinition&gt; parse(String configContent);\n}\n\npublic class XmlBeanConfigParser implements BeanConfigParser {\n\n  @Override\n  public List&lt;BeanDefinition&gt; parse(InputStream inputStream) {\n    String content = null;\n    \/\/ TODO:...\n    return parse(content);\n  }\n\n  @Override\n  public List&lt;BeanDefinition&gt; parse(String configContent) {\n    List&lt;BeanDefinition&gt; beanDefinitions = new ArrayList&lt;&gt;();\n    \/\/ TODO:...\n    return beanDefinitions;\n  }\n\n}\n\npublic class BeanDefinition {\n  private String id;\n  private String className;\n  private List&lt;ConstructorArg&gt; constructorArgs = new ArrayList&lt;&gt;();\n  private Scope scope = Scope.SINGLETON;\n  private boolean lazyInit = false;\n  \/\/ 省略必要的getter\/setter\/constructors\n \n  public boolean isSingleton() {\n    return scope.equals(Scope.SINGLETON);\n  }\n\n\n  public static enum Scope {\n    SINGLETON,\n    PROTOTYPE\n  }\n  \n  public static class ConstructorArg {\n    private boolean isRef;\n    private Class type;\n    private Object arg;\n    \/\/ 省略必要的getter\/setter\/constructors\n  }\n}\n<\/code><\/pre><h3>4.核心工厂类设计<\/h3><p>最后，我们来看，BeansFactory是如何设计和实现的。这也是我们这个DI容器最核心的一个类了。它负责根据从配置文件解析得到的BeanDefinition来创建对象。<\/p><p>如果对象的scope属性是singleton，那对象创建之后会缓存在singletonObjects这样一个map中，下次再请求此对象的时候，直接从map中取出返回，不需要重新创建。如果对象的scope属性是prototype，那每次请求对象，BeansFactory都会创建一个新的对象返回。<\/p><p>实际上，BeansFactory创建对象用到的主要技术点就是Java中的反射语法：一种动态加载类和创建对象的机制。我们知道，JVM在启动的时候会根据代码自动地加载类、创建对象。至于都要加载哪些类、创建哪些对象，这些都是在代码中写死的，或者说提前写好的。但是，如果某个对象的创建并不是写死在代码中，而是放到配置文件中，我们需要在程序运行期间，动态地根据配置文件来加载类、创建对象，那这部分工作就没法让JVM帮我们自动完成了，我们需要利用Java提供的反射语法自己去编写代码。<\/p><p>搞清楚了反射的原理，BeansFactory的代码就不难看懂了。具体代码实现如下所示：<\/p><pre><code>public class BeansFactory {\n  private ConcurrentHashMap&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;();\n  private ConcurrentHashMap&lt;String, BeanDefinition&gt; beanDefinitions = new ConcurrentHashMap&lt;&gt;();\n\n  public void addBeanDefinitions(List&lt;BeanDefinition&gt; beanDefinitionList) {\n    for (BeanDefinition beanDefinition : beanDefinitionList) {\n      this.beanDefinitions.putIfAbsent(beanDefinition.getId(), beanDefinition);\n    }\n\n    for (BeanDefinition beanDefinition : beanDefinitionList) {\n      if (beanDefinition.isLazyInit() == false &amp;&amp; beanDefinition.isSingleton()) {\n        createBean(beanDefinition);\n      }\n    }\n  }\n\n  public Object getBean(String beanId) {\n    BeanDefinition beanDefinition = beanDefinitions.get(beanId);\n    if (beanDefinition == null) {\n      throw new NoSuchBeanDefinitionException(&quot;Bean is not defined: &quot; + beanId);\n    }\n    return createBean(beanDefinition);\n  }\n\n  @VisibleForTesting\n  protected Object createBean(BeanDefinition beanDefinition) {\n    if (beanDefinition.isSingleton() &amp;&amp; singletonObjects.contains(beanDefinition.getId())) {\n      return singletonObjects.get(beanDefinition.getId());\n    }\n\n    Object bean = null;\n    try {\n      Class beanClass = Class.forName(beanDefinition.getClassName());\n      List&lt;BeanDefinition.ConstructorArg&gt; args = beanDefinition.getConstructorArgs();\n      if (args.isEmpty()) {\n        bean = beanClass.newInstance();\n      } else {\n        Class[] argClasses = new Class[args.size()];\n        Object[] argObjects = new Object[args.size()];\n        for (int i = 0; i &lt; args.size(); ++i) {\n          BeanDefinition.ConstructorArg arg = args.get(i);\n          if (!arg.getIsRef()) {\n            argClasses[i] = arg.getType();\n            argObjects[i] = arg.getArg();\n          } else {\n            BeanDefinition refBeanDefinition = beanDefinitions.get(arg.getArg());\n            if (refBeanDefinition == null) {\n              throw new NoSuchBeanDefinitionException(&quot;Bean is not defined: &quot; + arg.getArg());\n            }\n            argClasses[i] = Class.forName(refBeanDefinition.getClassName());\n            argObjects[i] = createBean(refBeanDefinition);\n          }\n        }\n        bean = beanClass.getConstructor(argClasses).newInstance(argObjects);\n      }\n    } catch (ClassNotFoundException | IllegalAccessException\n            | InstantiationException | NoSuchMethodException | InvocationTargetException e) {\n      throw new BeanCreationFailureException(&quot;&quot;, e);\n    }\n\n    if (bean != null &amp;&amp; beanDefinition.isSingleton()) {\n      singletonObjects.putIfAbsent(beanDefinition.getId(), bean);\n      return singletonObjects.get(beanDefinition.getId());\n    }\n    return bean;\n  }\n}\n<\/code><\/pre><h2>重点回顾<\/h2><p>好了，今天的内容到此就讲完了。我们来一块总结回顾一下，你需要重点掌握的内容。<\/p><p>DI容器在一些软件开发中已经成为了标配，比如Spring IOC、Google Guice。但是，大部分人可能只是把它当作一个黑盒子来使用，并未真正去了解它的底层是如何实现的。当然，如果只是做一些简单的小项目，简单会用就足够了，但是，如果我们面对的是非常复杂的系统，当系统出现问题的时候，对底层原理的掌握程度，决定了我们排查问题的能力，直接影响到我们排查问题的效率。<\/p><p>今天，我们讲解了一个简单的DI容器的实现原理，其核心逻辑主要包括：配置文件解析，以及根据配置文件通过“反射”语法来创建对象。其中，创建对象的过程就应用到了我们在学的工厂模式。对象创建、组装、管理完全有DI容器来负责，跟具体业务代码解耦，让程序员聚焦在业务代码的开发上。<\/p><h2>课堂讨论<\/h2><p>BeansFactory类中的createBean()函数是一个递归函数。当构造函数的参数是ref类型时，会递归地创建ref属性指向的对象。如果我们在配置文件中错误地配置了对象之间的依赖关系，导致存在循环依赖，那BeansFactory的createBean()函数是否会出现堆栈溢出？又该如何解决这个问题呢？<\/p><p>你可以可以在留言区说一说，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。<\/p>","footer_cover_data":{"img_url":"https:\/\/static001.geekbang.org\/resource\/image\/26\/2f\/262c882b3159d5a512c14d746e9be32f.png","link_url":"https:\/\/coding.geekbang.org\/activity\/algorithm-challenge?utm_source=geektime&utm_medium=article&utm_campaign=liebianactivity&utm_content=articlebottom&utm_term=geektime-article-liebianactivity-articlebottom","mp_url":""},"article_cover_hidden":false,"column_is_experience":false,"is_required":true,"rate":{"2":{"cur_version":0,"max_rate":0,"cur_rate":0,"is_finished":false,"total_rate":0,"learned_seconds":0},"1":{"cur_version":0,"max_rate":0,"cur_rate":0,"is_finished":false,"total_rate":0,"learned_seconds":0},"3":{"cur_version":0,"max_rate":0,"cur_rate":0,"is_finished":false,"total_rate":0,"learned_seconds":0}},"product_id":100039001,"like_count":114,"had_liked":false,"article_subtitle":"","audio_download_url":"https:\/\/static001.geekbang.org\/resource\/audio\/96\/ff\/9656485234582086d0fdd37ed1bc4fff.mp3","id":198614,"had_viewed":false,"article_title":"45 | 工厂模式（下）：如何设计实现一个Dependency Injection框架？","column_bgcolor":"#F6F7FB","share":{"content":"前Google工程师手把手教你写高质量代码","title":"王争 · 设计模式之美","poster":"https:\/\/static001.geekbang.org\/resource\/image\/bb\/16\/bbae9826fe7380857ad8edae52659a16.jpg","cover":"https:\/\/static001.geekbang.org\/resource\/image\/37\/47\/37db2297526f625866b66cee9aea0547.jpg"},"is_video_preview":false,"article_summary":"一个简单的DI容器的实现原理，其核心逻辑主要包括：配置文件解析、根据配置文件通过“反射”语法来创建对象。","article_poster_wxlite":"https:\/\/static001.geekbang.org\/render\/screen\/c9\/fa\/c9eb25ea7afb947803f03e6fef1da1fa.jpeg","column_sale_type":0,"article_features":0,"article_could_preview":false,"column_cover":"https:\/\/static001.geekbang.org\/resource\/image\/37\/47\/37db2297526f625866b66cee9aea0547.jpg","column_id":250,"audio_time_arr":{"m":"11","s":"09","h":"00"},"video_time":"","audio_title":"2.12 王争45","audio_md5":"9656485234582086d0fdd37ed1bc4fff","video_size":0,"text_read_percent":0,"comment_count":63,"cid":250,"article_sharetitle":"如何设计实现一个Dependency Injection框架？","column_is_onboard":true,"article_cshort":"<p>在上一节课我们讲到，当创建对象是一个“大工程”的时候，我们一般会选择使用工厂模式，来封装对象复杂的创建过程，将对象的创建和使用分离，让代码更加清晰。那何为“大工程”呢？上一节课中我们讲了两种情况，一种是创建过程涉及复杂的if-else分支判断，另一种是对象创建需要组装多个其他类对象或者需要复杂的初始化过程。<\/p><p>今天，我们再来讲一个创建对象的“大工程”，依赖注入框架，或者叫依赖注入容器（Dependency Injection Container），简称DI容器。在今天的讲解中，我会带你一块搞清楚这样几个问题：DI容器跟我们讲的工厂模式又有何区别和联系？DI容器的核心功能有哪些，以及如何实现一个简单的DI容器？<\/p><p>话不多说，让我们正式开始今天的学习吧！<\/p><h2>工厂模式和DI容器有何区别？<\/h2><p>实际上，DI容器底层最基本的设计思路就是基于工厂模式的。DI容器相当于一个大的工厂类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获取即可。正是因为它持有一堆对象，所以这个框架才被称为“容器”。<\/p><p>DI容器相对于我们上节课讲的工厂模式的例子来说，它处理的是更大的对象创建工程。上节课讲的工厂模式中，一个工厂类只负责某个类对象或者某一组相关类对象（继承自同一抽象类或者接口的子类）的创建，而DI容器负责的是整个应用中所有类对象的创建。<\/p>","video_width":0,"column_could_sub":true,"article_ctime":1581609600,"score":"71581609600"},"code":0}