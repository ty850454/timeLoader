{"error":[],"extra":[],"data":{"video_id":"","sku":"100039001","video_cover":"","author_name":"王争","text_read_version":0,"audio_size":8336845,"article_cover":"https:\/\/static001.geekbang.org\/resource\/image\/dc\/b0\/dcac6e445d44085a64b99d7c4ba1d2b0.jpg","product_type":"c1","audio_url":"https:\/\/res001.geekbang.org\/\/media\/audio\/74\/b6\/74b4161b42a466d1ee2eefd6327066b6\/ld\/ld.m3u8","chapter_id":"1289","column_had_sub":true,"audio_dubber":"冯永吉","is_finished":false,"like":{"had_done":false,"count":8},"neighbors":{"left":{"article_title":"57 | 观察者模式（下）：如何实现一个异步非阻塞的EventBus框架？","id":211239},"right":{"article_title":"59 | 模板模式（下）：模板模式与Callback回调函数有何区别和联系？","id":212802}},"audio_time":"00:08:40","video_height":0,"rate_percent":0,"article_content":"<p>上两节课我们学习了第一个行为型设计模式，观察者模式。针对不同的应用场景，我们讲解了不同的实现方式，有同步阻塞、异步非阻塞的实现方式，也有进程内、进程间的实现方式。除此之外，我还带你手把手实现了一个简单的EventBus框架。<\/p><p>今天，我们再学习另外一种行为型设计模式，模板模式。我们多次强调，绝大部分设计模式的原理和实现，都非常简单，难的是掌握应用场景，搞清楚能解决什么问题。模板模式也不例外。模板模式主要是用来解决复用和扩展两个问题。我们今天会结合Java Servlet、JUnit TestCase、Java InputStream、Java AbstractList四个例子来具体讲解这两个作用。<\/p><p>话不多说，让我们正式开始今天的学习吧！<\/p><h2>模板模式的原理与实现<\/h2><p>模板模式，全称是模板方法设计模式，英文是Template Method Design Pattern。在GoF的《设计模式》一书中，它是这么定义的：<\/p><blockquote>\n<p>Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.<\/p>\n<\/blockquote><!-- [[[read_end]]] --><p>翻译成中文就是：模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。<\/p><p>这里的“算法”，我们可以理解为广义上的“业务逻辑”，并不特指数据结构和算法中的“算法”。这里的算法骨架就是“模板”，包含算法骨架的方法就是“模板方法”，这也是模板方法模式名字的由来。<\/p><p>原理很简单，代码实现就更加简单，我写了一个示例代码，如下所示。templateMethod()函数定义为final，是为了避免子类重写它。method1()和method2()定义为abstract，是为了强迫子类去实现。不过，这些都不是必须的，在实际的项目开发中，模板模式的代码实现比较灵活，待会儿讲到应用场景的时候，我们会有具体的体现。<\/p><pre><code>public abstract class AbstractClass {\n  public final void templateMethod() {\n    \/\/...\n    method1();\n    \/\/...\n    method2();\n    \/\/...\n  }\n  \n  protected abstract void method1();\n  protected abstract void method2();\n}\n\npublic class ConcreteClass1 extends AbstractClass {\n  @Override\n  protected void method1() {\n    \/\/...\n  }\n  \n  @Override\n  protected void method2() {\n    \/\/...\n  }\n}\n\npublic class ConcreteClass2 extends AbstractClass {\n  @Override\n  protected void method1() {\n    \/\/...\n  }\n  \n  @Override\n  protected void method2() {\n    \/\/...\n  }\n}\n\nAbstractClass demo = ConcreteClass1();\ndemo.templateMethod();\n<\/code><\/pre><h2>模板模式作用一：复用<\/h2><p>开篇的时候，我们讲到模板模式有两大作用：复用和扩展。我们先来看它的第一个作用：复用。<\/p><p>模板模式把一个算法中不变的流程抽象到父类的模板方法templateMethod()中，将可变的部分method1()、method2()留给子类ContreteClass1和ContreteClass2来实现。所有的子类都可以复用父类中模板方法定义的流程代码。我们通过两个小例子来更直观地体会一下。<\/p><h3>1.Java InputStream<\/h3><p>Java IO类库中，有很多类的设计用到了模板模式，比如InputStream、OutputStream、Reader、Writer。我们拿InputStream来举例说明一下。<\/p><p>我把InputStream部分相关代码贴在了下面。在代码中，read()函数是一个模板方法，定义了读取数据的整个流程，并且暴露了一个可以由子类来定制的抽象方法。不过这个方法也被命名为了read()，只是参数跟模板方法不同。<\/p><pre><code>public abstract class InputStream implements Closeable {\n  \/\/...省略其他代码...\n  \n  public int read(byte b[], int off, int len) throws IOException {\n    if (b == null) {\n      throw new NullPointerException();\n    } else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) {\n      throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n      return 0;\n    }\n\n    int c = read();\n    if (c == -1) {\n      return -1;\n    }\n    b[off] = (byte)c;\n\n    int i = 1;\n    try {\n      for (; i &lt; len ; i++) {\n        c = read();\n        if (c == -1) {\n          break;\n        }\n        b[off + i] = (byte)c;\n      }\n    } catch (IOException ee) {\n    }\n    return i;\n  }\n  \n  public abstract int read() throws IOException;\n}\n\npublic class ByteArrayInputStream extends InputStream {\n  \/\/...省略其他代码...\n  \n  @Override\n  public synchronized int read() {\n    return (pos &lt; count) ? (buf[pos++] &amp; 0xff) : -1;\n  }\n}\n<\/code><\/pre><h3>2.Java AbstractList<\/h3><p>在Java AbstractList类中，addAll()函数可以看作模板方法，add()是子类需要重写的方法，尽管没有声明为abstract的，但函数实现直接抛出了UnsupportedOperationException异常。前提是，如果子类不重写是不能使用的。<\/p><pre><code>public boolean addAll(int index, Collection&lt;? extends E&gt; c) {\n    rangeCheckForAdd(index);\n    boolean modified = false;\n    for (E e : c) {\n        add(index++, e);\n        modified = true;\n    }\n    return modified;\n}\n\npublic void add(int index, E element) {\n    throw new UnsupportedOperationException();\n}\n<\/code><\/pre><h2>模板模式作用二：扩展<\/h2><p>模板模式的第二大作用的是扩展。这里所说的扩展，并不是指代码的扩展性，而是指框架的扩展性，有点类似我们之前讲到的控制反转，你可以结合<a href=\"https:\/\/time.geekbang.org\/column\/article\/177444\">第19节<\/a>来一块理解。基于这个作用，模板模式常用在框架的开发中，让框架用户可以在不修改框架源码的情况下，定制化框架的功能。我们通过Junit TestCase、Java Servlet两个例子来解释一下。<\/p><h3>1.Java Servlet<\/h3><p>对于Java Web项目开发来说，常用的开发框架是SpringMVC。利用它，我们只需要关注业务代码的编写，底层的原理几乎不会涉及。但是，如果我们抛开这些高级框架来开发Web项目，必然会用到Servlet。实际上，使用比较底层的Servlet来开发Web项目也不难。我们只需要定义一个继承HttpServlet的类，并且重写其中的doGet()或doPost()方法，来分别处理get和post请求。具体的代码示例如下所示：<\/p><pre><code>public class HelloServlet extends HttpServlet {\n  @Override\n  protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    this.doPost(req, resp);\n  }\n  \n  @Override\n  protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    resp.getWriter().write(&quot;Hello World.&quot;);\n  }\n}\n<\/code><\/pre><p>除此之外，我们还需要在配置文件web.xml中做如下配置。Tomcat、Jetty等Servlet容器在启动的时候，会自动加载这个配置文件中的URL和Servlet之间的映射关系。<\/p><pre><code>&lt;servlet&gt;\n    &lt;servlet-name&gt;HelloServlet&lt;\/servlet-name&gt;\n    &lt;servlet-class&gt;com.xzg.cd.HelloServlet&lt;\/servlet-class&gt;\n&lt;\/servlet&gt;\n\n&lt;servlet-mapping&gt;\n    &lt;servlet-name&gt;HelloServlet&lt;\/servlet-name&gt;\n    &lt;url-pattern&gt;\/hello&lt;\/url-pattern&gt;\n&lt;\/servlet-mapping&gt;\n<\/code><\/pre><p>当我们在浏览器中输入网址（比如，<a href=\"http:\/\/127.0.0.1:8080\/hello\">http:\/\/127.0.0.1:8080\/hello<\/a> ）的时候，Servlet容器会接收到相应的请求，并且根据URL和Servlet之间的映射关系，找到相应的Servlet（HelloServlet），然后执行它的service()方法。service()方法定义在父类HttpServlet中，它会调用doGet()或doPost()方法，然后输出数据（“Hello world”）到网页。<\/p><p>我们现在来看，HttpServlet的service()函数长什么样子。<\/p><pre><code>public void service(ServletRequest req, ServletResponse res)\n    throws ServletException, IOException\n{\n    HttpServletRequest  request;\n    HttpServletResponse response;\n    if (!(req instanceof HttpServletRequest &amp;&amp;\n            res instanceof HttpServletResponse)) {\n        throw new ServletException(&quot;non-HTTP request or response&quot;);\n    }\n    request = (HttpServletRequest) req;\n    response = (HttpServletResponse) res;\n    service(request, response);\n}\n\nprotected void service(HttpServletRequest req, HttpServletResponse resp)\n    throws ServletException, IOException\n{\n    String method = req.getMethod();\n    if (method.equals(METHOD_GET)) {\n        long lastModified = getLastModified(req);\n        if (lastModified == -1) {\n            \/\/ servlet doesn't support if-modified-since, no reason\n            \/\/ to go through further expensive logic\n            doGet(req, resp);\n        } else {\n            long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);\n            if (ifModifiedSince &lt; lastModified) {\n                \/\/ If the servlet mod time is later, call doGet()\n                \/\/ Round down to the nearest second for a proper compare\n                \/\/ A ifModifiedSince of -1 will always be less\n                maybeSetLastModified(resp, lastModified);\n                doGet(req, resp);\n            } else {\n                resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);\n            }\n        }\n    } else if (method.equals(METHOD_HEAD)) {\n        long lastModified = getLastModified(req);\n        maybeSetLastModified(resp, lastModified);\n        doHead(req, resp);\n    } else if (method.equals(METHOD_POST)) {\n        doPost(req, resp);\n    } else if (method.equals(METHOD_PUT)) {\n        doPut(req, resp);\n    } else if (method.equals(METHOD_DELETE)) {\n        doDelete(req, resp);\n    } else if (method.equals(METHOD_OPTIONS)) {\n        doOptions(req,resp);\n    } else if (method.equals(METHOD_TRACE)) {\n        doTrace(req,resp);\n    } else {\n        String errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;);\n        Object[] errArgs = new Object[1];\n        errArgs[0] = method;\n        errMsg = MessageFormat.format(errMsg, errArgs);\n        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);\n    }\n}\n<\/code><\/pre><p>从上面的代码中我们可以看出，HttpServlet的service()方法就是一个模板方法，它实现了整个HTTP请求的执行流程，doGet()、doPost()是模板中可以由子类来定制的部分。实际上，这就相当于Servlet框架提供了一个扩展点（doGet()、doPost()方法），让框架用户在不用修改Servlet框架源码的情况下，将业务代码通过扩展点镶嵌到框架中执行。<\/p><h3>2.JUnit TestCase<\/h3><p>跟Java Servlet类似，JUnit框架也通过模板模式提供了一些功能扩展点（setUp()、tearDown()等），让框架用户可以在这些扩展点上扩展功能。<\/p><p>在使用JUnit测试框架来编写单元测试的时候，我们编写的测试类都要继承框架提供的TestCase类。在TestCase类中，runBare()函数是模板方法，它定义了执行测试用例的整体流程：先执行setUp()做些准备工作，然后执行runTest()运行真正的测试代码，最后执行tearDown()做扫尾工作。<\/p><p>TestCase类的具体代码如下所示。尽管setUp()、tearDown()并不是抽象函数，还提供了默认的实现，不强制子类去重新实现，但\b这部分也是可以在子类中定制的，所以也符合模板模式的定义。<\/p><pre><code>public abstract class TestCase extends Assert implements Test {\n  public void runBare() throws Throwable {\n    Throwable exception = null;\n    setUp();\n    try {\n      runTest();\n    } catch (Throwable running) {\n      exception = running;\n    } finally {\n      try {\n        tearDown();\n      } catch (Throwable tearingDown) {\n        if (exception == null) exception = tearingDown;\n      }\n    }\n    if (exception != null) throw exception;\n  }\n  \n  \/**\n  * Sets up the fixture, for example, open a network connection.\n  * This method is called before a test is executed.\n  *\/\n  protected void setUp() throws Exception {\n  }\n\n  \/**\n  * Tears down the fixture, for example, close a network connection.\n  * This method is called after a test is executed.\n  *\/\n  protected void tearDown() throws Exception {\n  }\n}\n<\/code><\/pre><h2>重点回顾<\/h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。<\/p><p>模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。这里的“算法”，我们可以理解为广义上的“业务逻辑”，并不特指数据结构和算法中的“算法”。这里的算法骨架就是“模板”，包含算法骨架的方法就是“模板方法”，这也是模板方法模式名字的由来。<\/p><p>在模板模式经典的实现中，模板方法定义为final，可以避免被子类重写。需要子类重写的方法定义为abstract，可以强迫子类去实现。不过，在实际项目开发中，模板模式的实现比较灵活，以上两点都不是必须的。<\/p><p>模板模式有两大作用：复用和扩展。其中，复用指的是，所有的子类可以复用父类中提供的模板方法的代码。扩展指的是，框架通过模板模式提供功能扩展点，让框架用户可以在不修改框架源码的情况下，基于扩展点定制化框架的功能。<\/p><h2>课堂讨论<\/h2><p>假设一个框架中的某个类暴露了两个模板方法，并且定义了一堆供模板方法调用的抽象方法，代码示例如下所示。在项目开发中，即便我们只用到这个类的其中一个模板方法，我们还是要在子类中把所有的抽象方法都实现一遍，这相当于无效劳动，有没有其他方式来解决这个问题呢？<\/p><pre><code>public abstract class AbstractClass {\n  public final void templateMethod1() {\n    \/\/...\n    method1();\n    \/\/...\n    method2();\n    \/\/...\n  }\n  \n  public final void templateMethod2() {\n    \/\/...\n    method3();\n    \/\/...\n    method4();\n    \/\/...\n  }\n  \n  protected abstract void method1();\n  protected abstract void method2();\n  protected abstract void method3();\n  protected abstract void method4();\n}\n<\/code><\/pre><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。<\/p>","footer_cover_data":{"img_url":"https:\/\/static001.geekbang.org\/resource\/image\/26\/2f\/262c882b3159d5a512c14d746e9be32f.png","link_url":"https:\/\/coding.geekbang.org\/activity\/algorithm-challenge?utm_source=geektime&utm_medium=article&utm_campaign=liebianactivity&utm_content=articlebottom&utm_term=geektime-article-liebianactivity-articlebottom","mp_url":""},"article_cover_hidden":false,"column_is_experience":false,"is_required":true,"rate":{"2":{"cur_version":0,"max_rate":0,"cur_rate":0,"is_finished":false,"total_rate":0,"learned_seconds":0},"1":{"cur_version":0,"max_rate":0,"cur_rate":0,"is_finished":false,"total_rate":0,"learned_seconds":0},"3":{"cur_version":0,"max_rate":0,"cur_rate":0,"is_finished":false,"total_rate":0,"learned_seconds":0}},"product_id":100039001,"like_count":41,"had_liked":false,"article_subtitle":"","audio_download_url":"https:\/\/static001.geekbang.org\/resource\/audio\/74\/b6\/74b4161b42a466d1ee2eefd6327066b6.mp3","id":212049,"had_viewed":false,"article_title":"58 | 模板模式（上）：剖析模板模式在JDK、Servlet、JUnit等中的应用","column_bgcolor":"#F6F7FB","share":{"content":"前Google工程师手把手教你写高质量代码","title":"王争 · 设计模式之美","poster":"https:\/\/static001.geekbang.org\/resource\/image\/bb\/16\/bbae9826fe7380857ad8edae52659a16.jpg","cover":"https:\/\/static001.geekbang.org\/resource\/image\/37\/47\/37db2297526f625866b66cee9aea0547.jpg"},"is_video_preview":false,"article_summary":"模板模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。","article_poster_wxlite":"https:\/\/static001.geekbang.org\/render\/screen\/dd\/1e\/ddd40ff933e88117dcebe5ad4e6c851e.jpeg","column_sale_type":0,"article_features":0,"article_could_preview":false,"column_cover":"https:\/\/static001.geekbang.org\/resource\/image\/37\/47\/37db2297526f625866b66cee9aea0547.jpg","column_id":250,"audio_time_arr":{"m":"08","s":"40","h":"00"},"video_time":"","audio_title":"3.14 王争 音频-58_01","audio_md5":"74b4161b42a466d1ee2eefd6327066b6","video_size":0,"text_read_percent":0,"comment_count":84,"cid":250,"article_sharetitle":"剖析模板模式在JDK、Servlet、JUnit等中的应用","column_is_onboard":true,"article_cshort":"<p>上两节课我们学习了第一个行为型设计模式，观察者模式。针对不同的应用场景，我们讲解了不同的实现方式，有同步阻塞、异步非阻塞的实现方式，也有进程内、进程间的实现方式。除此之外，我还带你手把手实现了一个简单的EventBus框架。<\/p><p>今天，我们再学习另外一种行为型设计模式，模板模式。我们多次强调，绝大部分设计模式的原理和实现，都非常简单，难的是掌握应用场景，搞清楚能解决什么问题。模板模式也不例外。模板模式主要是用来解决复用和扩展两个问题。我们今天会结合Java Servlet、JUnit TestCase、Java InputStream、Java AbstractList四个例子来具体讲解这两个作用。<\/p><p>话不多说，让我们正式开始今天的学习吧！<\/p><h2>模板模式的原理与实现<\/h2><p>模板模式，全称是模板方法设计模式，英文是Template Method Design Pattern。在GoF的《设计模式》一书中，它是这么定义的：<\/p><blockquote>\n<p>Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.<\/p>\n<\/blockquote>","video_width":0,"column_could_sub":true,"article_ctime":1584288000,"score":"91584288000"},"code":0}