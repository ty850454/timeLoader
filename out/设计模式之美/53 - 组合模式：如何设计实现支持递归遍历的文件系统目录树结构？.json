{"error":[],"extra":[],"data":{"video_id":"","sku":"100039001","video_cover":"","author_name":"王争","text_read_version":0,"audio_size":6249862,"article_cover":"https:\/\/static001.geekbang.org\/resource\/image\/95\/91\/9515cf83c52e2f57cc00fd3ba58b7c91.jpg","product_type":"c1","audio_url":"https:\/\/res001.geekbang.org\/\/media\/audio\/b3\/fe\/b337355b2a4c41b4a35a477acd369dfe\/ld\/ld.m3u8","chapter_id":"1271","column_had_sub":true,"audio_dubber":"冯永吉","is_finished":false,"like":{"had_done":false,"count":5},"neighbors":{"left":{"article_title":"52 | 门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用性？","id":206409},"right":{"article_title":"54 | 享元模式（上）：如何利用享元模式优化文本编辑器的内存占用？","id":208572}},"audio_time":"00:06:30","video_height":0,"rate_percent":0,"article_content":"<p>结构型设计模式就快要讲完了，还剩下两个不那么常用的：组合模式和享元模式。今天，我们来讲一下<strong>组合模式<\/strong>（Composite Design Pattern）。<\/p><p>组合模式跟我们之前讲的面向对象设计中的“组合关系（通过组合来组装两个类）”，完全是两码事。这里讲的“组合模式”，主要是用来处理树形结构数据。这里的“数据”，你可以简单理解为一组对象集合，待会我们会详细讲解。<\/p><p>正因为其应用场景的特殊性，数据必须能表示成树形结构，这也导致了这种模式在实际的项目开发中并不那么常用。但是，一旦数据满足树形结构，应用这种模式就能发挥很大的作用，能让代码变得非常简洁。<\/p><p>话不多说，让我们正式开始今天的学习吧！<\/p><h2>组合模式的原理与实现<\/h2><p>在GoF的《设计模式》一书中，组合模式是这样定义的：<\/p><blockquote>\n<p>Compose objects into tree structure to represent part-whole hierarchies.Composite lets client treat individual objects and compositions of objects uniformly.<\/p>\n<\/blockquote><p>翻译成中文就是：将一组对象组织（Compose）成树形结构，以表示一种“部分-整体”的层次结构。组合让客户端（在很多设计模式书籍中，“客户端”代指代码的使用者。）可以统一单个对象和组合对象的处理逻辑。<\/p><!-- [[[read_end]]] --><p>接下来，对于组合模式，我举个例子来给你解释一下。<\/p><p>假设我们有这样一个需求：设计一个类来表示文件系统中的目录，能方便地实现下面这些功能：<\/p><ul>\n<li>动态地添加、删除某个目录下的子目录或文件；<\/li>\n<li>统计指定目录下的文件个数；<\/li>\n<li>统计指定目录下的文件总大小。<\/li>\n<\/ul><p>我这里给出了这个类的骨架代码，如下所示。其中的核心逻辑并未实现，你可以试着自己去补充完整，再来看我的讲解。在下面的代码实现中，我们把文件和目录统一用FileSystemNode类来表示，并且通过isFile属性来区分。<\/p><pre><code>public class FileSystemNode {\n  private String path;\n  private boolean isFile;\n  private List&lt;FileSystemNode&gt; subNodes = new ArrayList&lt;&gt;();\n\n  public FileSystemNode(String path, boolean isFile) {\n    this.path = path;\n    this.isFile = isFile;\n  }\n\n  public int countNumOfFiles() {\n    \/\/ TODO:...\n  }\n\n  public long countSizeOfFiles() {\n    \/\/ TODO:...\n  }\n\n  public String getPath() {\n    return path;\n  }\n\n  public void addSubNode(FileSystemNode fileOrDir) {\n    subNodes.add(fileOrDir);\n  }\n\n  public void removeSubNode(FileSystemNode fileOrDir) {\n    int size = subNodes.size();\n    int i = 0;\n    for (; i &lt; size; ++i) {\n      if (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) {\n        break;\n      }\n    }\n    if (i &lt; size) {\n      subNodes.remove(i);\n    }\n  }\n}\n<\/code><\/pre><p>实际上，如果你看过我的《数据结构与算法之美》专栏，想要补全其中的countNumOfFiles()和countSizeOfFiles()这两个函数，并不是件难事，实际上这就是树上的递归遍历算法。对于文件，我们直接返回文件的个数（返回1）或大小。对于目录，我们遍历目录中每个子目录或者文件，递归计算它们的个数或大小，然后求和，就是这个目录下的文件个数和文件大小。<\/p><p>我把两个函数的代码实现贴在下面了，你可以对照着看一下。<\/p><pre><code>  public int countNumOfFiles() {\n    if (isFile) {\n      return 1;\n    }\n    int numOfFiles = 0;\n    for (FileSystemNode fileOrDir : subNodes) {\n      numOfFiles += fileOrDir.countNumOfFiles();\n    }\n    return numOfFiles;\n  }\n\n  public long countSizeOfFiles() {\n    if (isFile) {\n      File file = new File(path);\n      if (!file.exists()) return 0;\n      return file.length();\n    }\n    long sizeofFiles = 0;\n    for (FileSystemNode fileOrDir : subNodes) {\n      sizeofFiles += fileOrDir.countSizeOfFiles();\n    }\n    return sizeofFiles;\n  }\n<\/code><\/pre><p>单纯从功能实现角度来说，上面的代码没有问题，已经实现了我们想要的功能。但是，如果我们开发的是一个大型系统，从扩展性（文件或目录可能会对应不同的操作）、业务建模（文件和目录从业务上是两个概念）、代码的可读性（文件和目录区分对待更加符合人们对业务的认知）的角度来说，我们最好对文件和目录进行区分设计，定义为File和Directory两个类。<\/p><p>按照这个设计思路，我们对代码进行重构。重构之后的代码如下所示：<\/p><pre><code>public abstract class FileSystemNode {\n  protected String path;\n\n  public FileSystemNode(String path) {\n    this.path = path;\n  }\n\n  public abstract int countNumOfFiles();\n  public abstract long countSizeOfFiles();\n\n  public String getPath() {\n    return path;\n  }\n}\n\npublic class File extends FileSystemNode {\n  public File(String path) {\n    super(path);\n  }\n\n  @Override\n  public int countNumOfFiles() {\n    return 1;\n  }\n\n  @Override\n  public long countSizeOfFiles() {\n    java.io.File file = new java.io.File(path);\n    if (!file.exists()) return 0;\n    return file.length();\n  }\n}\n\npublic class Directory extends FileSystemNode {\n  private List&lt;FileSystemNode&gt; subNodes = new ArrayList&lt;&gt;();\n\n  public Directory(String path) {\n    super(path);\n  }\n\n  @Override\n  public int countNumOfFiles() {\n    int numOfFiles = 0;\n    for (FileSystemNode fileOrDir : subNodes) {\n      numOfFiles += fileOrDir.countNumOfFiles();\n    }\n    return numOfFiles;\n  }\n\n  @Override\n  public long countSizeOfFiles() {\n    long sizeofFiles = 0;\n    for (FileSystemNode fileOrDir : subNodes) {\n      sizeofFiles += fileOrDir.countSizeOfFiles();\n    }\n    return sizeofFiles;\n  }\n\n  public void addSubNode(FileSystemNode fileOrDir) {\n    subNodes.add(fileOrDir);\n  }\n\n  public void removeSubNode(FileSystemNode fileOrDir) {\n    int size = subNodes.size();\n    int i = 0;\n    for (; i &lt; size; ++i) {\n      if (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) {\n        break;\n      }\n    }\n    if (i &lt; size) {\n      subNodes.remove(i);\n    }\n  }\n}\n<\/code><\/pre><p>文件和目录类都设计好了，我们来看，如何用它们来表示一个文件系统中的目录树结构。具体的代码示例如下所示：<\/p><pre><code>public class Demo {\n  public static void main(String[] args) {\n    \/**\n     * \/\n     * \/wz\/\n     * \/wz\/a.txt\n     * \/wz\/b.txt\n     * \/wz\/movies\/\n     * \/wz\/movies\/c.avi\n     * \/xzg\/\n     * \/xzg\/docs\/\n     * \/xzg\/docs\/d.txt\n     *\/\n    Directory fileSystemTree = new Directory(&quot;\/&quot;);\n    Directory node_wz = new Directory(&quot;\/wz\/&quot;);\n    Directory node_xzg = new Directory(&quot;\/xzg\/&quot;);\n    fileSystemTree.addSubNode(node_wz);\n    fileSystemTree.addSubNode(node_xzg);\n\n    File node_wz_a = new File(&quot;\/wz\/a.txt&quot;);\n    File node_wz_b = new File(&quot;\/wz\/b.txt&quot;);\n    Directory node_wz_movies = new Directory(&quot;\/wz\/movies\/&quot;);\n    node_wz.addSubNode(node_wz_a);\n    node_wz.addSubNode(node_wz_b);\n    node_wz.addSubNode(node_wz_movies);\n\n    File node_wz_movies_c = new File(&quot;\/wz\/movies\/c.avi&quot;);\n    node_wz_movies.addSubNode(node_wz_movies_c);\n\n    Directory node_xzg_docs = new Directory(&quot;\/xzg\/docs\/&quot;);\n    node_xzg.addSubNode(node_xzg_docs);\n\n    File node_xzg_docs_d = new File(&quot;\/xzg\/docs\/d.txt&quot;);\n    node_xzg_docs.addSubNode(node_xzg_docs_d);\n\n    System.out.println(&quot;\/ files num:&quot; + fileSystemTree.countNumOfFiles());\n    System.out.println(&quot;\/wz\/ files num:&quot; + node_wz.countNumOfFiles());\n  }\n}\n<\/code><\/pre><p>我们对照着这个例子，再重新看一下组合模式的定义：“将一组对象（文件和目录）组织成树形结构，以表示一种‘部分-整体’的层次结构（目录与子目录的嵌套结构）。组合模式让客户端可以统一单个对象（文件）和组合对象（目录）的处理逻辑（递归遍历）。”<\/p><p>实际上，刚才讲的这种组合模式的设计思路，与其说是一种设计模式，倒不如说是对业务场景的一种数据结构和算法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算法来实现。<\/p><h2>组合模式的应用场景举例<\/h2><p>刚刚我们讲了文件系统的例子，对于组合模式，我这里再举一个例子。搞懂了这两个例子，你基本上就算掌握了组合模式。在实际的项目中，遇到类似的可以表示成树形结构的业务场景，你只要“照葫芦画瓢”去设计就可以了。<\/p><p>假设我们在开发一个OA系统（办公自动化系统）。公司的组织结构包含部门和员工两种数据类型。其中，部门又可以包含子部门和员工。在数据库中的表结构如下所示：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/5b\/8b\/5b19dc0c296f728328794eab1f16a38b.jpg\" alt=\"\"><\/p><p>我们希望在内存中构建整个公司的人员架构图（部门、子部门、员工的隶属关系），并且提供接口计算出部门的薪资成本（隶属于这个部门的所有员工的薪资和）。<\/p><p>部门包含子部门和员工，这是一种嵌套结构，可以表示成树这种数据结构。计算每个部门的薪资开支这样一个需求，也可以通过在树上的遍历算法来实现。所以，从这个角度来看，这个应用场景可以使用组合模式来设计和实现。<\/p><p>这个例子的代码结构跟上一个例子的很相似，代码实现我直接贴在了下面，你可以对比着看一下。其中，HumanResource是部门类（Department）和员工类（Employee）抽象出来的父类，为的是能统一薪资的处理逻辑。Demo中的代码负责从数据库中读取数据并在内存中构建组织架构图。<\/p><pre><code>public abstract class HumanResource {\n  protected long id;\n  protected double salary;\n\n  public HumanResource(long id) {\n    this.id = id;\n  }\n\n  public long getId() {\n    return id;\n  }\n\n  public abstract double calculateSalary();\n}\n\npublic class Employee extends HumanResource {\n  public Employee(long id, double salary) {\n    super(id);\n    this.salary = salary;\n  }\n\n  @Override\n  public double calculateSalary() {\n    return salary;\n  }\n}\n\npublic class Department extends HumanResource {\n  private List&lt;HumanResource&gt; subNodes = new ArrayList&lt;&gt;();\n\n  public Department(long id) {\n    super(id);\n  }\n\n  @Override\n  public double calculateSalary() {\n    double totalSalary = 0;\n    for (HumanResource hr : subNodes) {\n      totalSalary += hr.calculateSalary();\n    }\n    this.salary = totalSalary;\n    return totalSalary;\n  }\n\n  public void addSubNode(HumanResource hr) {\n    subNodes.add(hr);\n  }\n}\n\n\/\/ 构建组织架构的代码\npublic class Demo {\n  private static final long ORGANIZATION_ROOT_ID = 1001;\n  private DepartmentRepo departmentRepo; \/\/ 依赖注入\n  private EmployeeRepo employeeRepo; \/\/ 依赖注入\n\n  public void buildOrganization() {\n    Department rootDepartment = new Department(ORGANIZATION_ROOT_ID);\n    buildOrganization(rootDepartment);\n  }\n\n  private void buildOrganization(Department department) {\n    List&lt;Long&gt; subDepartmentIds = departmentRepo.getSubDepartmentIds(department.getId());\n    for (Long subDepartmentId : subDepartmentIds) {\n      Department subDepartment = new Department(subDepartmentId);\n      department.addSubNode(subDepartment);\n      buildOrganization(subDepartment);\n    }\n    List&lt;Long&gt; employeeIds = employeeRepo.getDepartmentEmployeeIds(department.getId());\n    for (Long employeeId : employeeIds) {\n      double salary = employeeRepo.getEmployeeSalary(employeeId);\n      department.addSubNode(new Employee(employeeId, salary));\n    }\n  }\n}\n<\/code><\/pre><p>我们再拿组合模式的定义跟这个例子对照一下：“将一组对象（员工和部门）组织成树形结构，以表示一种‘部分-整体’的层次结构（部门与子部门的嵌套结构）。组合模式让客户端可以统一单个对象（员工）和组合对象（部门）的处理逻辑（递归遍历）。”<\/p><h2>重点回顾<\/h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。<\/p><p>组合模式的设计思路，与其说是一种设计模式，倒不如说是对业务场景的一种数据结构和算法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算法来实现。<\/p><p>组合模式，将一组对象组织成树形结构，将单个对象和组合对象都看做树中的节点，以统一处理逻辑，并且它利用树形结构的特点，递归地处理每个子树，依次简化代码实现。使用组合模式的前提在于，你的业务场景必须能够表示成树形结构。所以，组合模式的应用场景也比较局限，它并不是一种很常用的设计模式。<\/p><h2>课堂讨论<\/h2><p>在文件系统那个例子中，countNumOfFiles()和countSizeOfFiles()这两个函数实现的效率并不高，因为每次调用它们的时候，都要重新遍历一遍子树。有没有什么办法可以提高这两个函数的执行效率呢（注意：文件系统还会涉及频繁的删除、添加文件操作，也就是对应Directory类中的addSubNode()和removeSubNode()函数）？<\/p><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。<\/p>","footer_cover_data":{"img_url":"https:\/\/static001.geekbang.org\/resource\/image\/26\/2f\/262c882b3159d5a512c14d746e9be32f.png","link_url":"https:\/\/coding.geekbang.org\/activity\/algorithm-challenge?utm_source=geektime&utm_medium=article&utm_campaign=liebianactivity&utm_content=articlebottom&utm_term=geektime-article-liebianactivity-articlebottom","mp_url":""},"article_cover_hidden":false,"column_is_experience":false,"is_required":true,"rate":{"2":{"cur_version":0,"max_rate":0,"cur_rate":0,"is_finished":false,"total_rate":0,"learned_seconds":0},"1":{"cur_version":0,"max_rate":0,"cur_rate":0,"is_finished":false,"total_rate":0,"learned_seconds":0},"3":{"cur_version":0,"max_rate":0,"cur_rate":0,"is_finished":false,"total_rate":0,"learned_seconds":0}},"product_id":100039001,"like_count":44,"had_liked":false,"article_subtitle":"","audio_download_url":"https:\/\/static001.geekbang.org\/resource\/audio\/b3\/fe\/b337355b2a4c41b4a35a477acd369dfe.mp3","id":207456,"had_viewed":false,"article_title":"53 | 组合模式：如何设计实现支持递归遍历的文件系统目录树结构？","column_bgcolor":"#F6F7FB","share":{"content":"前Google工程师手把手教你写高质量代码","title":"王争 · 设计模式之美","poster":"https:\/\/static001.geekbang.org\/resource\/image\/bb\/16\/bbae9826fe7380857ad8edae52659a16.jpg","cover":"https:\/\/static001.geekbang.org\/resource\/image\/37\/47\/37db2297526f625866b66cee9aea0547.jpg"},"is_video_preview":false,"article_summary":"组合模式，将一组对象组织成树形结构，将单个对象和组合对象都看做树中的节点，并利用树形结构的特点，简化代码实现。","article_poster_wxlite":"https:\/\/static001.geekbang.org\/render\/screen\/5a\/c4\/5a6b2eaec149060a0ff92609c55b0bc4.jpeg","column_sale_type":0,"article_features":0,"article_could_preview":false,"column_cover":"https:\/\/static001.geekbang.org\/resource\/image\/37\/47\/37db2297526f625866b66cee9aea0547.jpg","column_id":250,"audio_time_arr":{"m":"06","s":"30","h":"00"},"video_time":"","audio_title":"3.3 王争 音频-53","audio_md5":"b337355b2a4c41b4a35a477acd369dfe","video_size":0,"text_read_percent":0,"comment_count":39,"cid":250,"article_sharetitle":"如何设计实现支持递归遍历的文件系统目录树结构？","column_is_onboard":true,"article_cshort":"<p>结构型设计模式就快要讲完了，还剩下两个不那么常用的：组合模式和享元模式。今天，我们来讲一下<strong>组合模式<\/strong>（Composite Design Pattern）。<\/p><p>组合模式跟我们之前讲的面向对象设计中的“组合关系（通过组合来组装两个类）”，完全是两码事。这里讲的“组合模式”，主要是用来处理树形结构数据。这里的“数据”，你可以简单理解为一组对象集合，待会我们会详细讲解。<\/p><p>正因为其应用场景的特殊性，数据必须能表示成树形结构，这也导致了这种模式在实际的项目开发中并不那么常用。但是，一旦数据满足树形结构，应用这种模式就能发挥很大的作用，能让代码变得非常简洁。<\/p><p>话不多说，让我们正式开始今天的学习吧！<\/p><h2>组合模式的原理与实现<\/h2><p>在GoF的《设计模式》一书中，组合模式是这样定义的：<\/p><blockquote>\n<p>Compose objects into tree structure to represent part-whole hierarchies.Composite lets client treat individual objects and compositions of objects uniformly.<\/p>\n<\/blockquote><p>翻译成中文就是：将一组对象组织（Compose）成树形结构，以表示一种“部分-整体”的层次结构。组合让客户端（在很多设计模式书籍中，“客户端”代指代码的使用者。）可以统一单个对象和组合对象的处理逻辑。<\/p>","video_width":0,"column_could_sub":true,"article_ctime":1583251200,"score":"81583251200"},"code":0}