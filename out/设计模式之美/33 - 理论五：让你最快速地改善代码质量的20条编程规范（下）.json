{"error":[],"extra":[],"data":{"video_id":"","sku":"100039001","video_cover":"","author_name":"王争","text_read_version":0,"audio_size":8421244,"article_cover":"https:\/\/static001.geekbang.org\/resource\/image\/a0\/5c\/a0d875bf70c91d432cba1e3e9646fc5c.jpg","product_type":"c1","audio_url":"https:\/\/res001.geekbang.org\/\/media\/audio\/3d\/f5\/3d70a002608ebd837fe6dc3c6f899ff5\/ld\/ld.m3u8","chapter_id":"1202","column_had_sub":true,"audio_dubber":"冯永吉","is_finished":false,"like":{"had_done":false,"count":11},"neighbors":{"left":{"article_title":"32 | 理论五：让你最快速地改善代码质量的20条编程规范（中）","id":188857},"right":{"article_title":"34 | 实战一（上）：通过一段ID生成器代码，学习如何发现代码质量问题","id":190979}},"audio_time":"00:10:01","video_height":0,"rate_percent":0,"article_content":"<p>上两节课，我们讲了命名和注释、代码风格，今天我们来讲一些比较实用的编程技巧，帮你切实地提高代码可读性。这部分技巧比较琐碎，也很难罗列全面，我仅仅总结了一些我认为比较关键的，更多的技巧需要你在实践中自己慢慢总结、积累。<\/p><p>话不多说，让我们正式开始今天的学习吧！<\/p><h2>1.把代码分割成更小的单元块<\/h2><p>大部分人阅读代码的习惯都是，先看整体再看细节。所以，我们要有模块化和抽象思维，善于将大块的复杂逻辑提炼成类或者函数，屏蔽掉细节，让阅读代码的人不至于迷失在细节中，这样能极大地提高代码的可读性。不过，只有代码逻辑比较复杂的时候，我们其实才建议提炼类或者函数。毕竟如果提炼出的函数只包含两三行代码，在阅读代码的时候，还得跳过去看一下，这样反倒增加了阅读成本。<\/p><p>这里我举一个例子来进一步解释一下。代码具体如下所示。重构前，在invest()函数中，最开始的那段关于时间处理的代码，是不是很难看懂？重构之后，我们将这部分逻辑抽象成一个函数，并且命名为isLastDayOfMonth，从名字就能清晰地了解它的功能，判断今天是不是当月的最后一天。这里，我们就是通过将复杂的逻辑代码提炼成函数，大大提高了代码的可读性。<\/p><pre><code>\/\/ 重构前的代码\npublic void invest(long userId, long financialProductId) {\n  Calendar calendar = Calendar.getInstance();\n  calendar.setTime(date);\n  calendar.set(Calendar.DATE, (calendar.get(Calendar.DATE) + 1));\n  if (calendar.get(Calendar.DAY_OF_MONTH) == 1) {\n    return;\n  }\n  \/\/...\n}\n\n\/\/ 重构后的代码：提炼函数之后逻辑更加清晰\npublic void invest(long userId, long financialProductId) {\n  if (isLastDayOfMonth(new Date())) {\n    return;\n  }\n  \/\/...\n}\n\npublic boolean isLastDayOfMonth(Date date) {\n  Calendar calendar = Calendar.getInstance();\n  calendar.setTime(date);\n  calendar.set(Calendar.DATE, (calendar.get(Calendar.DATE) + 1));\n  if (calendar.get(Calendar.DAY_OF_MONTH) == 1) {\n   return true;\n  }\n  return false;\n}\n<\/code><\/pre><!-- [[[read_end]]] --><h2>2.避免函数参数过多<\/h2><p>我个人觉得，函数包含3、4个参数的时候还是能接受的，大于等于5个的时候，我们就觉得参数有点过多了，会影响到代码的可读性，使用起来也不方便。针对参数过多的情况，一般有2种处理方法。<\/p><ul>\n<li>考虑函数是否职责单一，是否能通过拆分成多个函数的方式来减少参数。示例代码如下所示：<\/li>\n<\/ul><pre><code>public User getUser(String username, String telephone, String email);\n\n\/\/ 拆分成多个函数\npublic User getUserByUsername(String username);\npublic User getUserByTelephone(String telephone);\npublic User getUserByEmail(String email);\n<\/code><\/pre><ul>\n<li>将函数的参数封装成对象。示例代码如下所示：<\/li>\n<\/ul><pre><code>public void postBlog(String title, String summary, String keywords, String content, String category, long authorId);\n\n\/\/ 将参数封装成对象\npublic class Blog {\n  private String title;\n  private String summary;\n  private String keywords;\n  private Strint content;\n  private String category;\n  private long authorId;\n}\npublic void postBlog(Blog blog);\n<\/code><\/pre><p>除此之外，如果函数是对外暴露的远程接口，将参数封装成对象，还可以提高接口的兼容性。在往接口中添加新的参数的时候，老的远程接口调用者有可能就不需要修改代码来兼容新的接口了。<\/p><h2>3.勿用函数参数来控制逻辑<\/h2><p>不要在函数中使用布尔类型的标识参数来控制内部逻辑，true的时候走这块逻辑，false的时候走另一块逻辑。这明显违背了单一职责原则和接口隔离原则。我建议将其拆成两个函数，可读性上也要更好。我举个例子来说明一下。<\/p><pre><code>public void buyCourse(long userId, long courseId, boolean isVip);\n\n\/\/ 将其拆分成两个函数\npublic void buyCourse(long userId, long courseId);\npublic void buyCourseForVip(long userId, long courseId);\n<\/code><\/pre><p>不过，如果函数是private私有函数，影响范围有限，或者拆分之后的两个函数经常同时被调用，我们可以酌情考虑保留标识参数。示例代码如下所示：<\/p><pre><code>\/\/ 拆分成两个函数的调用方式\nboolean isVip = false;\n\/\/...省略其他逻辑...\nif (isVip) {\n  buyCourseForVip(userId, courseId);\n} else {\n  buyCourse(userId, courseId);\n}\n\n\/\/ 保留标识参数的调用方式更加简洁\nboolean isVip = false;\n\/\/...省略其他逻辑...\nbuyCourse(userId, courseId, isVip);\n<\/code><\/pre><p>除了布尔类型作为标识参数来控制逻辑的情况外，还有一种“根据参数是否为null”来控制逻辑的情况。针对这种情况，我们也应该将其拆分成多个函数。拆分之后的函数职责更明确，不容易用错。具体代码示例如下所示：<\/p><pre><code>public List&lt;Transaction&gt; selectTransactions(Long userId, Date startDate, Date endDate) {\n  if (startDate != null &amp;&amp; endDate != null) {\n    \/\/ 查询两个时间区间的transactions\n  }\n  if (startDate != null &amp;&amp; endDate == null) {\n    \/\/ 查询startDate之后的所有transactions\n  }\n  if (startDate == null &amp;&amp; endDate != null) {\n    \/\/ 查询endDate之前的所有transactions\n  }\n  if (startDate == null &amp;&amp; endDate == null) {\n    \/\/ 查询所有的transactions\n  }\n}\n\n\/\/ 拆分成多个public函数，更加清晰、易用\npublic List&lt;Transaction&gt; selectTransactionsBetween(Long userId, Date startDate, Date endDate) {\n  return selectTransactions(userId, startDate, endDate);\n}\n\npublic List&lt;Transaction&gt; selectTransactionsStartWith(Long userId, Date startDate) {\n  return selectTransactions(userId, startDate, null);\n}\n\npublic List&lt;Transaction&gt; selectTransactionsEndWith(Long userId, Date endDate) {\n  return selectTransactions(userId, null, endDate);\n}\n\npublic List&lt;Transaction&gt; selectAllTransactions(Long userId) {\n  return selectTransactions(userId, null, null);\n}\n\nprivate List&lt;Transaction&gt; selectTransactions(Long userId, Date startDate, Date endDate) {\n  \/\/ ...\n}\n<\/code><\/pre><h2>4.函数设计要职责单一<\/h2><p>我们在前面讲到单一职责原则的时候，针对的是类、模块这样的应用对象。实际上，对于函数的设计来说，更要满足单一职责原则。相对于类和模块，函数的粒度比较小，代码行数少，所以在应用单一职责原则的时候，没有像应用到类或者模块那样模棱两可，能多单一就多单一。<\/p><p>具体的代码示例如下所示：<\/p><pre><code>public boolean checkUserIfExisting(String telephone, String username, String email)  { \n  if (!StringUtils.isBlank(telephone)) {\n    User user = userRepo.selectUserByTelephone(telephone);\n    return user != null;\n  }\n  \n  if (!StringUtils.isBlank(username)) {\n    User user = userRepo.selectUserByUsername(username);\n    return user != null;\n  }\n  \n  if (!StringUtils.isBlank(email)) {\n    User user = userRepo.selectUserByEmail(email);\n    return user != null;\n  }\n  \n  return false;\n}\n\n\/\/ 拆分成三个函数\npublic boolean checkUserIfExistingByTelephone(String telephone);\npublic boolean checkUserIfExistingByUsername(String username);\npublic boolean checkUserIfExistingByEmail(String email);\n<\/code><\/pre><h2>5.移除过深的嵌套层次<\/h2><p>代码嵌套层次过深往往是因为if-else、switch-case、for循环过度嵌套导致的。我个人建议，嵌套最好不超过两层，超过两层之后就要思考一下是否可以减少嵌套。过深的嵌套本身理解起来就比较费劲，除此之外，嵌套过深很容易因为代码多次缩进，导致嵌套内部的语句超过一行的长度而折成两行，影响代码的整洁。<\/p><p>解决嵌套过深的方法也比较成熟，有下面4种常见的思路。<\/p><ul>\n<li>去掉多余的if或else语句。代码示例如下所示：<\/li>\n<\/ul><pre><code>\/\/ 示例一\npublic double caculateTotalAmount(List&lt;Order&gt; orders) {\n  if (orders == null || orders.isEmpty()) {\n    return 0.0;\n  } else { \/\/ 此处的else可以去掉\n    double amount = 0.0;\n    for (Order order : orders) {\n      if (order != null) {\n        amount += (order.getCount() * order.getPrice());\n      }\n    }\n    return amount;\n  }\n}\n\n\/\/ 示例二\npublic List&lt;String&gt; matchStrings(List&lt;String&gt; strList,String substr) {\n  List&lt;String&gt; matchedStrings = new ArrayList&lt;&gt;();\n  if (strList != null &amp;&amp; substr != null) {\n    for (String str : strList) {\n      if (str != null) { \/\/ 跟下面的if语句可以合并在一起\n        if (str.contains(substr)) {\n          matchedStrings.add(str);\n        }\n      }\n    }\n  }\n  return matchedStrings;\n}\n<\/code><\/pre><ul>\n<li>使用编程语言提供的continue、break、return关键字，提前退出嵌套。代码示例如下所示：<\/li>\n<\/ul><pre><code>\/\/ 重构前的代码\npublic List&lt;String&gt; matchStrings(List&lt;String&gt; strList,String substr) {\n  List&lt;String&gt; matchedStrings = new ArrayList&lt;&gt;();\n  if (strList != null &amp;&amp; substr != null){ \n    for (String str : strList) {\n      if (str != null &amp;&amp; str.contains(substr)) {\n        matchedStrings.add(str);\n        \/\/ 此处还有10行代码...\n      }\n    }\n  }\n  return matchedStrings;\n}\n\n\/\/ 重构后的代码：使用continue提前退出\npublic List&lt;String&gt; matchStrings(List&lt;String&gt; strList,String substr) {\n  List&lt;String&gt; matchedStrings = new ArrayList&lt;&gt;();\n  if (strList != null &amp;&amp; substr != null){ \n    for (String str : strList) {\n      if (str == null || !str.contains(substr)) {\n        continue; \n      }\n      matchedStrings.add(str);\n      \/\/ 此处还有10行代码...\n    }\n  }\n  return matchedStrings;\n}\n<\/code><\/pre><ul>\n<li>调整执行顺序来减少嵌套。具体的代码示例如下所示：<\/li>\n<\/ul><pre><code>\/\/ 重构前的代码\npublic List&lt;String&gt; matchStrings(List&lt;String&gt; strList,String substr) {\n  List&lt;String&gt; matchedStrings = new ArrayList&lt;&gt;();\n  if (strList != null &amp;&amp; substr != null) {\n    for (String str : strList) {\n      if (str != null) {\n        if (str.contains(substr)) {\n          matchedStrings.add(str);\n        }\n      }\n    }\n  }\n  return matchedStrings;\n}\n\n\/\/ 重构后的代码：先执行判空逻辑，再执行正常逻辑\npublic List&lt;String&gt; matchStrings(List&lt;String&gt; strList,String substr) {\n  if (strList == null || substr == null) { \/\/先判空\n    return Collections.emptyList();\n  }\n\n  List&lt;String&gt; matchedStrings = new ArrayList&lt;&gt;();\n  for (String str : strList) {\n    if (str != null) {\n      if (str.contains(substr)) {\n        matchedStrings.add(str);\n      }\n    }\n  }\n  return matchedStrings;\n}\n<\/code><\/pre><ul>\n<li>将部分嵌套逻辑封装成函数调用，以此来减少嵌套。具体的代码示例如下所示：<\/li>\n<\/ul><pre><code>\/\/ 重构前的代码\npublic List&lt;String&gt; appendSalts(List&lt;String&gt; passwords) {\n  if (passwords == null || passwords.isEmpty()) {\n    return Collections.emptyList();\n  }\n  \n  List&lt;String&gt; passwordsWithSalt = new ArrayList&lt;&gt;();\n  for (String password : passwords) {\n    if (password == null) {\n      continue;\n    }\n    if (password.length() &lt; 8) {\n      \/\/ ...\n    } else {\n      \/\/ ...\n    }\n  }\n  return passwordsWithSalt;\n}\n\n\/\/ 重构后的代码：将部分逻辑抽成函数\npublic List&lt;String&gt; appendSalts(List&lt;String&gt; passwords) {\n  if (passwords == null || passwords.isEmpty()) {\n    return Collections.emptyList();\n  }\n\n  List&lt;String&gt; passwordsWithSalt = new ArrayList&lt;&gt;();\n  for (String password : passwords) {\n    if (password == null) {\n      continue;\n    }\n    passwordsWithSalt.add(appendSalt(password));\n  }\n  return passwordsWithSalt;\n}\n\nprivate String appendSalt(String password) {\n  String passwordWithSalt = password;\n  if (password.length() &lt; 8) {\n    \/\/ ...\n  } else {\n    \/\/ ...\n  }\n  return passwordWithSalt;\n}\n<\/code><\/pre><p>除此之外，常用的还有通过使用多态来替代if-else、switch-case条件判断的方法。这个思路涉及代码结构的改动，我们会在后面的章节中讲到，这里就暂时不展开说明了。<\/p><h2>6.学会使用解释性变量<\/h2><p>常用的用解释性变量来提高代码的可读性的情况有下面2种。<\/p><ul>\n<li>常量取代魔法数字。示例代码如下所示：<\/li>\n<\/ul><pre><code>public double CalculateCircularArea(double radius) {\n  return (3.1415) * radius * radius;\n}\n\n\/\/ 常量替代魔法数字\npublic static final Double PI = 3.1415;\npublic double CalculateCircularArea(double radius) {\n  return PI * radius * radius;\n}\n<\/code><\/pre><ul>\n<li>使用解释性变量来解释复杂表达式。示例代码如下所示：<\/li>\n<\/ul><pre><code>if (date.after(SUMMER_START) &amp;&amp; date.before(SUMMER_END)) {\n  \/\/ ...\n} else {\n  \/\/ ...\n}\n\n\/\/ 引入解释性变量后逻辑更加清晰\nboolean isSummer = date.after(SUMMER_START)&amp;&amp;date.before(SUMMER_END);\nif (isSummer) {\n  \/\/ ...\n} else {\n  \/\/ ...\n} \n<\/code><\/pre><h2>重点回顾<\/h2><p>好了，今天的内容到此就讲完了。除了今天讲的编程技巧，前两节课我们还分别讲解了命名与注释、代码风格。现在，我们一块来回顾复习一下这三节课的重点内容。<\/p><p><strong>1.关于命名<\/strong><\/p><ul>\n<li>命名的关键是能准确达意。对于不同作用域的命名，我们可以适当地选择不同的长度。<\/li>\n<li>我们可以借助类的信息来简化属性、函数的命名，利用函数的信息来简化函数参数的命名。<\/li>\n<li>命名要可读、可搜索。不要使用生僻的、不好读的英文单词来命名。命名要符合项目的统一规范，也不要用些反直觉的命名。<\/li>\n<li>接口有两种命名方式：一种是在接口中带前缀“I”；另一种是在接口的实现类中带后缀“Impl”。对于抽象类的命名，也有两种方式，一种是带上前缀“Abstract”，一种是不带前缀。这两种命名方式都可以，关键是要在项目中统一。<\/li>\n<\/ul><p><strong>2.关于注释<\/strong><\/p><ul>\n<li>注释的内容主要包含这样三个方面：做什么、为什么、怎么做。对于一些复杂的类和接口，我们可能还需要写明“如何用”。<\/li>\n<li>类和函数一定要写注释，而且要写得尽可能全面详细。函数内部的注释要相对少一些，一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码可读性。<\/li>\n<\/ul><p><strong>3.关于代码风格<\/strong><\/p><ul>\n<li>函数、类多大才合适？函数的代码行数不要超过一屏幕的大小，比如50行。类的大小限制比较难确定。<\/li>\n<li>一行代码多长最合适？最好不要超过IDE的显示宽度。当然，也不能太小，否则会导致很多稍微长点的语句被折成两行，也会影响到代码的整洁，不利于阅读。<\/li>\n<li>善用空行分割单元块。对于比较长的函数，为了让逻辑更加清晰，可以使用空行来分割各个代码块。<\/li>\n<li>四格缩进还是两格缩进？我个人比较推荐使用两格缩进，这样可以节省空间，尤其是在代码嵌套层次比较深的情况下。不管是用两格缩进还是四格缩进，一定不要用tab键缩进。<\/li>\n<li>大括号是否要另起一行？将大括号放到跟上一条语句同一行，可以节省代码行数。但是将大括号另起新的一行的方式，左右括号可以垂直对齐，哪些代码属于哪一个代码块，更加一目了然。<\/li>\n<li>类中成员怎么排列？在Google Java编程规范中，依赖类按照字母序从小到大排列。类中先写成员变量后写函数。成员变量之间或函数之间，先写静态成员变量或函数，后写普通变量或函数，并且按照作用域大小依次排列。<\/li>\n<\/ul><p><strong>4.关于编码技巧<\/strong><\/p><ul>\n<li>将复杂的逻辑提炼拆分成函数和类。<\/li>\n<li>通过拆分成多个函数或将参数封装为对象的方式，来处理参数过多的情况。<\/li>\n<li>函数中不要使用参数来做代码执行逻辑的控制。<\/li>\n<li>函数设计要职责单一。<\/li>\n<li>移除过深的嵌套层次，方法包括：去掉多余的if或else语句，使用continue、break、return关键字提前退出嵌套，调整执行顺序来减少嵌套，将部分嵌套逻辑抽象成函数。<\/li>\n<li>用字面常量取代魔法数。<\/li>\n<li>用解释性变量来解释复杂表达式，以此提高代码可读性。<\/li>\n<\/ul><p><strong>5.统一编码规范<\/strong><\/p><p>除了这三节讲到的比较细节的知识点之外，最后，还有一条非常重要的，那就是，项目、团队，甚至公司，一定要制定统一的编码规范，并且通过Code Review督促执行，这对提高代码质量有立竿见影的效果。<\/p><h2>课堂讨论<\/h2><p>到此为止，我们整个20条编码规范就讲完了。不知道你掌握了多少呢？除了今天我提到的这些，还有哪些其他的编程技巧，可以明显改善代码的可读性？<\/p><p>试着在留言区总结罗列一下，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。<\/p>","footer_cover_data":{"img_url":"https:\/\/static001.geekbang.org\/resource\/image\/26\/2f\/262c882b3159d5a512c14d746e9be32f.png","link_url":"https:\/\/coding.geekbang.org\/activity\/algorithm-challenge?utm_source=geektime&utm_medium=article&utm_campaign=liebianactivity&utm_content=articlebottom&utm_term=geektime-article-liebianactivity-articlebottom","mp_url":""},"article_cover_hidden":false,"column_is_experience":false,"is_required":true,"rate":{"2":{"cur_version":0,"max_rate":0,"cur_rate":0,"is_finished":false,"total_rate":0,"learned_seconds":0},"1":{"cur_version":0,"max_rate":0,"cur_rate":0,"is_finished":false,"total_rate":0,"learned_seconds":0},"3":{"cur_version":0,"max_rate":0,"cur_rate":0,"is_finished":false,"total_rate":0,"learned_seconds":0}},"product_id":100039001,"like_count":118,"had_liked":false,"article_subtitle":"","audio_download_url":"https:\/\/static001.geekbang.org\/resource\/audio\/3d\/f5\/3d70a002608ebd837fe6dc3c6f899ff5.mp3","id":188882,"had_viewed":false,"article_title":"33 | 理论五：让你最快速地改善代码质量的20条编程规范（下）","column_bgcolor":"#F6F7FB","share":{"content":"前Google工程师手把手教你写高质量代码","title":"王争 · 设计模式之美","poster":"https:\/\/static001.geekbang.org\/resource\/image\/bb\/16\/bbae9826fe7380857ad8edae52659a16.jpg","cover":"https:\/\/static001.geekbang.org\/resource\/image\/37\/47\/37db2297526f625866b66cee9aea0547.jpg"},"is_video_preview":false,"article_summary":"上两节课，我们讲了命名和注释、代码风格，今天我们来讲一些比较实用的编程技巧，帮你切实地提高代码可读性。","article_poster_wxlite":"https:\/\/static001.geekbang.org\/render\/screen\/52\/11\/520e1001c8c993ab83fd883b85fa2b11.jpeg","column_sale_type":0,"article_features":0,"article_could_preview":false,"column_cover":"https:\/\/static001.geekbang.org\/resource\/image\/37\/47\/37db2297526f625866b66cee9aea0547.jpg","column_id":250,"audio_time_arr":{"m":"10","s":"01","h":"00"},"video_time":"","audio_title":"1.11王争音频-33_01","audio_md5":"3d70a002608ebd837fe6dc3c6f899ff5","video_size":0,"text_read_percent":0,"comment_count":77,"cid":250,"article_sharetitle":"让你最快速地改善代码质量的20条编程规范（下）","column_is_onboard":true,"article_cshort":"<p>上两节课，我们讲了命名和注释、代码风格，今天我们来讲一些比较实用的编程技巧，帮你切实地提高代码可读性。这部分技巧比较琐碎，也很难罗列全面，我仅仅总结了一些我认为比较关键的，更多的技巧需要你在实践中自己慢慢总结、积累。<\/p><p>话不多说，让我们正式开始今天的学习吧！<\/p><h2>1.把代码分割成更小的单元块<\/h2><p>大部分人阅读代码的习惯都是，先看整体再看细节。所以，我们要有模块化和抽象思维，善于将大块的复杂逻辑提炼成类或者函数，屏蔽掉细节，让阅读代码的人不至于迷失在细节中，这样能极大地提高代码的可读性。不过，只有代码逻辑比较复杂的时候，我们其实才建议提炼类或者函数。毕竟如果提炼出的函数只包含两三行代码，在阅读代码的时候，还得跳过去看一下，这样反倒增加了阅读成本。<\/p><p>这里我举一个例子来进一步解释一下。代码具体如下所示。重构前，在invest()函数中，最开始的那段关于时间处理的代码，是不是很难看懂？重构之后，我们将这部分逻辑抽象成一个函数，并且命名为isLastDayOfMonth，从名字就能清晰地了解它的功能，判断今天是不是当月的最后一天。这里，我们就是通过将复杂的逻辑代码提炼成函数，大大提高了代码的可读性。<\/p><pre><code>\/\/ 重构前的代码\npublic void invest(long userId, long financialProductId) {\n  Calendar calendar = Calendar.getInstance();\n  calendar.setTime(date);\n  calendar.set(Calendar.DATE, (calendar.get(Calendar.DATE) + 1));\n  if (calendar.get(Calendar.DAY_OF_MONTH) == 1) {\n    return;\n  }\n  \/\/...\n}\n\n\/\/ 重构后的代码：提炼函数之后逻辑更加清晰\npublic void invest(long userId, long financialProductId) {\n  if (isLastDayOfMonth(new Date())) {\n    return;\n  }\n  \/\/...\n}\n\npublic boolean isLastDayOfMonth(Date date) {\n  Calendar calendar = Calendar.getInstance();\n  calendar.setTime(date);\n  calendar.set(Calendar.DATE, (calendar.get(Calendar.DATE) + 1));\n  if (calendar.get(Calendar.DAY_OF_MONTH) == 1) {\n   return true;\n  }\n  return false;\n}\n<\/code><\/pre>","video_width":0,"column_could_sub":true,"article_ctime":1579190400,"score":"51579190400"},"code":0}