{"error":[],"extra":[],"data":{"video_id":"","sku":"100039001","video_cover":"","author_name":"王争","text_read_version":0,"audio_size":8989498,"article_cover":"https:\/\/static001.geekbang.org\/resource\/image\/bc\/7e\/bc2c7b86308e44a0333f4f50976bba7e.jpg","product_type":"c1","audio_url":"https:\/\/res001.geekbang.org\/\/media\/audio\/34\/e3\/34113447e067e27945bd0aa575a34ee3\/ld\/ld.m3u8","chapter_id":"1289","column_had_sub":true,"audio_dubber":"冯永吉","is_finished":false,"like":{"had_done":false,"count":11},"neighbors":{"left":{"article_title":"66 | 迭代器模式（中）：遍历集合的同时，为什么不能增删集合元素？","id":219964},"right":{"article_title":"68 | 访问者模式（上）：手把手带你还原访问者模式诞生的思维过程","id":221852}},"audio_time":"00:09:21","video_height":0,"rate_percent":0,"article_content":"<p>上两节课，我们学习了迭代器模式的原理、实现，并且分析了在遍历集合的同时增删集合元素，产生不可预期结果的原因以及应对策略。<\/p><p>今天，我们再来看这样一个问题：如何实现一个支持“快照”功能的迭代器？这个问题算是对上一节课内容的延伸思考，为的是帮你加深对迭代器模式的理解，也是对你分析、解决问题的一种锻炼。你可以把它当作一个面试题或者练习题，在看我的讲解之前，先试一试自己能否顺利回答上来。<\/p><p>话不多说，让我们正式开始今天的学习吧！<\/p><h2>问题描述<\/h2><p>我们先来介绍一下问题的背景：如何实现一个支持“快照”功能的迭代器模式？<\/p><p>理解这个问题最关键的是理解“快照”两个字。所谓“快照”，指我们为容器创建迭代器的时候，相当于给容器拍了一张快照（Snapshot）。之后即便我们增删容器中的元素，快照中的元素并不会做相应的改动。而迭代器遍历的对象是快照而非容器，这样就避免了在使用迭代器遍历的过程中，增删容器中的元素，导致的不可预期的结果或者报错。<\/p><p>接下来，我举一个例子来解释一下上面这段话。具体的代码如下所示。容器list中初始存储了3、8、2三个元素。尽管在创建迭代器iter1之后，容器list删除了元素3，只剩下8、2两个元素，但是，通过iter1遍历的对象是快照，而非容器list本身。所以，遍历的结果仍然是3、8、2。同理，iter2、iter3也是在各自的快照上遍历，输出的结果如代码中注释所示。<\/p><!-- [[[read_end]]] --><pre><code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\nlist.add(3);\nlist.add(8);\nlist.add(2);\n\nIterator&lt;Integer&gt; iter1 = list.iterator();\/\/snapshot: 3, 8, 2\nlist.remove(new Integer(2));\/\/list：3, 8\nIterator&lt;Integer&gt; iter2 = list.iterator();\/\/snapshot: 3, 8\nlist.remove(new Integer(3));\/\/list：8\nIterator&lt;Integer&gt; iter3 = list.iterator();\/\/snapshot: 3\n\n\/\/ 输出结果：3 8 2\nwhile (iter1.hasNext()) {\n  System.out.print(iter1.next() + &quot; &quot;);\n}\nSystem.out.println();\n\n\/\/ 输出结果：3 8\nwhile (iter2.hasNext()) {\n  System.out.print(iter1.next() + &quot; &quot;);\n}\nSystem.out.println();\n\n\/\/ 输出结果：8\nwhile (iter3.hasNext()) {\n  System.out.print(iter1.next() + &quot; &quot;);\n}\nSystem.out.println();\n<\/code><\/pre><p>如果由你来实现上面的功能，你会如何来做呢？下面是针对这个功能需求的骨架代码，其中包含ArrayList、SnapshotArrayIterator两个类。对于这两个类，我只定义了必须的几个关键接口，完整的代码实现我并没有给出。你可以试着去完善一下，然后再看我下面的讲解。<\/p><pre><code>public ArrayList&lt;E&gt; implements List&lt;E&gt; {\n  \/\/ TODO: 成员变量、私有函数等随便你定义\n  \n  @Override\n  public void add(E obj) {\n    \/\/TODO: 由你来完善\n  }\n  \n  @Override\n  public void remove(E obj) {\n    \/\/ TODO: 由你来完善\n  }\n  \n  @Override\n  public Iterator&lt;E&gt; iterator() {\n    return new SnapshotArrayIterator(this);\n  }\n}\n\npublic class SnapshotArrayIterator&lt;E&gt; implements Iterator&lt;E&gt; {\n  \/\/ TODO: 成员变量、私有函数等随便你定义\n  \n  @Override\n  public boolean hasNext() {\n    \/\/ TODO: 由你来完善\n  }\n  \n  @Override\n  public E next() {\/\/返回当前元素，并且游标后移一位\n    \/\/ TODO: 由你来完善\n  }\n}\n<\/code><\/pre><h2>解决方案一<\/h2><p>我们先来看最简单的一种解决办法。在迭代器类中定义一个成员变量snapshot来存储快照。每当创建迭代器的时候，都拷贝一份容器中的元素到快照中，后续的遍历操作都基于这个迭代器自己持有的快照来进行。具体的代码实现如下所示：<\/p><pre><code>public class SnapshotArrayIterator&lt;E&gt; implements Iterator&lt;E&gt; {\n  private int cursor;\n  private ArrayList&lt;E&gt; snapshot;\n\n  public SnapshotArrayIterator(ArrayList&lt;E&gt; arrayList) {\n    this.cursor = 0;\n    this.snapshot = new ArrayList&lt;&gt;();\n    this.snapshot.addAll(arrayList);\n  }\n\n  @Override\n  public boolean hasNext() {\n    return cursor &lt; snapshot.size();\n  }\n\n  @Override\n  public E next() {\n    E currentItem = snapshot.get(cursor);\n    cursor++;\n    return currentItem;\n  }\n}\n<\/code><\/pre><p>这个解决方案虽然简单，但代价也有点高。每次创建迭代器的时候，都要拷贝一份数据到快照中，会增加内存的消耗。如果一个容器同时有多个迭代器在遍历元素，就会导致数据在内存中重复存储多份。不过，庆幸的是，Java中的拷贝属于浅拷贝，也就是说，容器中的对象并非真的拷贝了多份，而只是拷贝了对象的引用而已。关于深拷贝、浅拷贝，我们在<a href=\"https:\/\/time.geekbang.org\/column\/article\/200786\">第47讲<\/a>中有详细的讲解，你可以回过头去再看一下。<\/p><p>那有没有什么方法，既可以支持快照，又不需要拷贝容器呢？<\/p><h2>解决方案二<\/h2><p>我们再来看第二种解决方案。<\/p><p>我们可以在容器中，为每个元素保存两个时间戳，一个是添加时间戳addTimestamp，一个是删除时间戳delTimestamp。当元素被加入到集合中的时候，我们将addTimestamp设置为当前时间，将delTimestamp设置成最大长整型值（Long.MAX_VALUE）。当元素被删除时，我们将delTimestamp更新为当前时间，表示已经被删除。<\/p><p>注意，这里只是标记删除，而非真正将它从容器中删除。<\/p><p>同时，每个迭代器也保存一个迭代器创建时间戳snapshotTimestamp，也就是迭代器对应的快照的创建时间戳。当使用迭代器来遍历容器的时候，只有满足addTimestamp&lt;snapshotTimestamp&lt;delTimestamp的元素，才是属于这个迭代器的快照。<\/p><p>如果元素的addTimestamp&gt;snapshotTimestamp，说明元素在创建了迭代器之后才加入的，不属于这个迭代器的快照；如果元素的delTimestamp&lt;snapshotTimestamp，说明元素在创建迭代器之前就被删除掉了，也不属于这个迭代器的快照。<\/p><p>这样就在不拷贝容器的情况下，在容器本身上借助时间戳实现了快照功能。具体的代码实现如下所示。注意，我们没有考虑ArrayList的扩容问题，感兴趣的话，你可以自己完善一下。<\/p><pre><code>public class ArrayList&lt;E&gt; implements List&lt;E&gt; {\n  private static final int DEFAULT_CAPACITY = 10;\n\n  private int actualSize; \/\/不包含标记删除元素\n  private int totalSize; \/\/包含标记删除元素\n\n  private Object[] elements;\n  private long[] addTimestamps;\n  private long[] delTimestamps;\n\n  public ArrayList() {\n    this.elements = new Object[DEFAULT_CAPACITY];\n    this.addTimestamps = new long[DEFAULT_CAPACITY];\n    this.delTimestamps = new long[DEFAULT_CAPACITY];\n    this.totalSize = 0;\n    this.actualSize = 0;\n  }\n\n  @Override\n  public void add(E obj) {\n    elements[totalSize] = obj;\n    addTimestamps[totalSize] = System.currentTimeMillis();\n    delTimestamps[totalSize] = Long.MAX_VALUE;\n    totalSize++;\n    actualSize++;\n  }\n\n  @Override\n  public void remove(E obj) {\n    for (int i = 0; i &lt; totalSize; ++i) {\n      if (elements[i].equals(obj)) {\n        delTimestamps[i] = System.currentTimeMillis();\n        actualSize--;\n      }\n    }\n  }\n\n  public int actualSize() {\n    return this.actualSize;\n  }\n\n  public int totalSize() {\n    return this.totalSize;\n  }\n\n  public E get(int i) {\n    if (i &gt;= totalSize) {\n      throw new IndexOutOfBoundsException();\n    }\n    return (E)elements[i];\n  }\n\n  public long getAddTimestamp(int i) {\n    if (i &gt;= totalSize) {\n      throw new IndexOutOfBoundsException();\n    }\n    return addTimestamps[i];\n  }\n\n  public long getDelTimestamp(int i) {\n    if (i &gt;= totalSize) {\n      throw new IndexOutOfBoundsException();\n    }\n    return delTimestamps[i];\n  }\n}\n\npublic class SnapshotArrayIterator&lt;E&gt; implements Iterator&lt;E&gt; {\n  private long snapshotTimestamp;\n  private int cursorInAll; \/\/ 在整个容器中的下标，而非快照中的下标\n  private int leftCount; \/\/ 快照中还有几个元素未被遍历\n  private ArrayList&lt;E&gt; arrayList;\n\n  public SnapshotArrayIterator(ArrayList&lt;E&gt; arrayList) {\n    this.snapshotTimestamp = System.currentTimeMillis();\n    this.cursorInAll = 0;\n    this.leftCount = arrayList.actualSize();;\n    this.arrayList = arrayList;\n\n    justNext(); \/\/ 先跳到这个迭代器快照的第一个元素\n  }\n\n  @Override\n  public boolean hasNext() {\n    return this.leftCount &gt;= 0; \/\/ 注意是&gt;=, 而非&gt;\n  }\n\n  @Override\n  public E next() {\n    E currentItem = arrayList.get(cursorInAll);\n    justNext();\n    return currentItem;\n  }\n\n  private void justNext() {\n    while (cursorInAll &lt; arrayList.totalSize()) {\n      long addTimestamp = arrayList.getAddTimestamp(cursorInAll);\n      long delTimestamp = arrayList.getDelTimestamp(cursorInAll);\n      if (snapshotTimestamp &gt; addTimestamp &amp;&amp; snapshotTimestamp &lt; delTimestamp) {\n        leftCount--;\n        break;\n      }\n      cursorInAll++;\n    }\n  }\n}\n<\/code><\/pre><p>实际上，上面的解决方案相当于解决了一个问题，又引入了另外一个问题。ArrayList底层依赖数组这种数据结构，原本可以支持快速的随机访问，在O(1)时间复杂度内获取下标为i的元素，但现在，删除数据并非真正的删除，只是通过时间戳来标记删除，这就导致无法支持按照下标快速随机访问了。如果你对数组随机访问这块知识点不了解，可以去看我的《数据结构与算法之美》专栏，这里我就不展开讲解了。<\/p><p>现在，我们来看怎么解决这个问题：让容器既支持快照遍历，又支持随机访问？<\/p><p>解决的方法也不难，我稍微提示一下。我们可以在ArrayList中存储两个数组。一个支持标记删除的，用来实现快照遍历功能；一个不支持标记删除的（也就是将要删除的数据直接从数组中移除），用来支持随机访问。对应的代码我这里就不给出了，感兴趣的话你可以自己实现一下。<\/p><h2>重点回顾<\/h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。<\/p><p>今天我们讲了如何实现一个支持“快照”功能的迭代器。其实这个问题本身并不是学习的重点，因为在真实的项目开发中，我们几乎不会遇到这样的需求。所以，基于今天的内容我不想做过多的总结。我想和你说一说，为什么我要来讲今天的内容呢？<\/p><p>实际上，学习本节课的内容，如果你只是从前往后看一遍，看懂就觉得ok了，那收获几乎是零。一个好学习方法是，把它当作一个思考题或者面试题，在看我的讲解之前，自己主动思考如何解决，并且把解决方案用代码实现一遍，然后再来看跟我的讲解有哪些区别。这个过程对你分析问题、解决问题的能力的锻炼，代码设计能力、编码能力的锻炼，才是最有价值的，才是我们这篇文章的意义所在。所谓“知识是死的，能力才是活的”就是这个道理。<\/p><p>其实，不仅仅是这一节的内容，整个专栏的学习都是这样的。<\/p><p>在《数据结构与算法之美》专栏中，有同学曾经对我说，他看了很多遍我的专栏，几乎看懂了所有的内容，他觉得都掌握了，但是，在最近第一次面试中，面试官给他出了一个结合实际开发的算法题，他还是没有思路，当时脑子一片放空，问我学完这个专栏之后，要想应付算法面试，还要学哪些东西，有没有推荐的书籍。<\/p><p>我看了他的面试题之后发现，用我专栏里讲的知识是完全可以解决的，而且，专栏里已经讲过类似的问题，只是换了个业务背景而已。之所以他没法回答上来，还是没有将知识转化成解决问题的能力，因为他只是被动地“看”，从来没有主动地“思考”。<strong>只掌握了知识，没锻炼能力，遇到实际的问题还是没法自己去分析、思考、解决<\/strong>。<\/p><p>我给他的建议是，把专栏里的每个开篇问题都当做面试题，自己去思考一下，然后再看解答。这样整个专栏学下来，对能力的锻炼就多了，再遇到算法面试也就不会一点思路都没有了。同理，学习《设计模式之美》这个专栏也应该如此。<\/p><h2>课堂讨论<\/h2><p>在今天讲的解决方案二中，删除元素只是被标记删除。被删除的元素即便在没有迭代器使用的情况下，也不会从数组中真正移除，这就会导致不必要的内存占用。针对这个问题，你有进一步优化的方法吗？<\/p><p>欢迎留言和我分享你的思考。如果有收获，欢迎你把这篇文章分享给你的朋友。<\/p>","footer_cover_data":{"img_url":"https:\/\/static001.geekbang.org\/resource\/image\/26\/2f\/262c882b3159d5a512c14d746e9be32f.png","link_url":"https:\/\/coding.geekbang.org\/activity\/algorithm-challenge?utm_source=geektime&utm_medium=article&utm_campaign=liebianactivity&utm_content=articlebottom&utm_term=geektime-article-liebianactivity-articlebottom","mp_url":""},"article_cover_hidden":false,"column_is_experience":false,"is_required":true,"rate":{"2":{"cur_version":0,"max_rate":0,"cur_rate":0,"is_finished":false,"total_rate":0,"learned_seconds":0},"1":{"cur_version":0,"max_rate":0,"cur_rate":0,"is_finished":false,"total_rate":0,"learned_seconds":0},"3":{"cur_version":0,"max_rate":0,"cur_rate":0,"is_finished":false,"total_rate":0,"learned_seconds":0}},"product_id":100039001,"like_count":33,"had_liked":false,"article_subtitle":"","audio_download_url":"https:\/\/static001.geekbang.org\/resource\/audio\/34\/e3\/34113447e067e27945bd0aa575a34ee3.mp3","id":221269,"had_viewed":false,"article_title":"67 | 迭代器模式（下）：如何设计实现一个支持“快照”功能的iterator？","column_bgcolor":"#F6F7FB","share":{"content":"前Google工程师手把手教你写高质量代码","title":"王争 · 设计模式之美","poster":"https:\/\/static001.geekbang.org\/resource\/image\/bb\/16\/bbae9826fe7380857ad8edae52659a16.jpg","cover":"https:\/\/static001.geekbang.org\/resource\/image\/37\/47\/37db2297526f625866b66cee9aea0547.jpg"},"is_video_preview":false,"article_summary":"这一节的问题算是对上一节课内容的延伸思考，为的是帮你加深对迭代器模式的理解，也是对你分析、解决问题的一种锻炼。","article_poster_wxlite":"https:\/\/static001.geekbang.org\/render\/screen\/08\/b4\/08a06f5791a8b6025845a44d0d632cb4.jpeg","column_sale_type":0,"article_features":0,"article_could_preview":false,"column_cover":"https:\/\/static001.geekbang.org\/resource\/image\/37\/47\/37db2297526f625866b66cee9aea0547.jpg","column_id":250,"audio_time_arr":{"m":"09","s":"21","h":"00"},"video_time":"","audio_title":"4.5 修改 王争 音频-67_01_01","audio_md5":"34113447e067e27945bd0aa575a34ee3","video_size":0,"text_read_percent":0,"comment_count":52,"cid":250,"article_sharetitle":"如何设计实现一个支持“快照”功能的iterator？","column_is_onboard":true,"article_cshort":"<p>上两节课，我们学习了迭代器模式的原理、实现，并且分析了在遍历集合的同时增删集合元素，产生不可预期结果的原因以及应对策略。<\/p><p>今天，我们再来看这样一个问题：如何实现一个支持“快照”功能的迭代器？这个问题算是对上一节课内容的延伸思考，为的是帮你加深对迭代器模式的理解，也是对你分析、解决问题的一种锻炼。你可以把它当作一个面试题或者练习题，在看我的讲解之前，先试一试自己能否顺利回答上来。<\/p><p>话不多说，让我们正式开始今天的学习吧！<\/p><h2>问题描述<\/h2><p>我们先来介绍一下问题的背景：如何实现一个支持“快照”功能的迭代器模式？<\/p><p>理解这个问题最关键的是理解“快照”两个字。所谓“快照”，指我们为容器创建迭代器的时候，相当于给容器拍了一张快照（Snapshot）。之后即便我们增删容器中的元素，快照中的元素并不会做相应的改动。而迭代器遍历的对象是快照而非容器，这样就避免了在使用迭代器遍历的过程中，增删容器中的元素，导致的不可预期的结果或者报错。<\/p><p>接下来，我举一个例子来解释一下上面这段话。具体的代码如下所示。容器list中初始存储了3、8、2三个元素。尽管在创建迭代器iter1之后，容器list删除了元素3，只剩下8、2两个元素，但是，通过iter1遍历的对象是快照，而非容器list本身。所以，遍历的结果仍然是3、8、2。同理，iter2、iter3也是在各自的快照上遍历，输出的结果如代码中注释所示。<\/p>","video_width":0,"column_could_sub":true,"article_ctime":1586102400,"score":"91586102400"},"code":0}